<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="东京下雨，淋湿巴黎">
<meta property="og:type" content="website">
<meta property="og:title" content="苏远的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="苏远的博客">
<meta property="og:description" content="东京下雨，淋湿巴黎">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏远的博客">
<meta name="twitter:description" content="东京下雨，淋湿巴黎">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>苏远的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e56d57ba89bb058da8fdd8841e98770f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏远的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/构造、解构、拷贝 语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/构造、解构、拷贝 语意学/" itemprop="url">构造、解构、拷贝 语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T23:41:22+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="几点类设计原则"><a href="#几点类设计原则" class="headerlink" title="几点类设计原则"></a>几点类设计原则</h2><ul>
<li><p>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。</p>
</li>
<li><p>不要将析构函数设计为纯虚的，这不是一个好的设计。将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。一个不能派生继承类的抽象类有什么存在的意义？必须定义纯虚析构函数，而不能仅仅声明它的原因在于：每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的析构函数声明，则去调用它的实体，而不管它有没有被定义。</p>
</li>
<li><p>真的必要的时候才使用虚函数，不要滥用虚函数。虚函数意味着不小的成本，编译很可能给你的类带来膨胀效应：</p>
<ul>
<li>每一个对象要多负担一个word的vptr。</li>
<li>给每一个构造函数（不论是显示的还是编译器合成的），插入一些代码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前。没有构造函数则需要合成，并插入代码。</li>
<li>合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对vptr的初始化代码，有的话也需要插入vptr的初始化代码。</li>
<li>意味着，如果具有bitwise语意，将不再具有，然后是变大的对象、没有那么高效的构造函数，没有那么高效的复制控制。</li>
</ul>
</li>
<li><p>不能决定一个虚函数是否需要 const ，那么就不要它。</p>
</li>
<li><p>决不在构造函数或析构函数中使用虚函数机制。在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。这是由vptr初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p>
</li>
</ul>
<h2 id="构造、复制、析构语意学"><a href="#构造、复制、析构语意学" class="headerlink" title="构造、复制、析构语意学"></a>构造、复制、析构语意学</h2><p>一种所谓的Plain OI’Data声明形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    float x,y,z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>概念上来讲，对于一段这样的C++代码,编译器会为之合成一个默认构造函数、复制构造函数、析构函数、赋值操作符。然而实际上编译器会分析这段代码，并给Point贴上Plain OI’Data标签。编译器在此后对于Point的处理与在C中完全一样,也就是说上述的函数都不会被合成。可见概念上应当由编译器合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。由此一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的方法来完成上面的功能，比方复制控制会用bitwise copy。</p>
<h3 id="对象构造语意学"><a href="#对象构造语意学" class="headerlink" title="对象构造语意学"></a>对象构造语意学</h3><h3 id="无继承情况下的对象构造：略。"><a href="#无继承情况下的对象构造：略。" class="headerlink" title="无继承情况下的对象构造：略。"></a>无继承情况下的对象构造：略。</h3><h4 id="单继承体系下的对象构造"><a href="#单继承体系下的对象构造" class="headerlink" title="单继承体系下的对象构造"></a>单继承体系下的对象构造</h4><p>对于简单定义的一个对象T object;,很明显它的默认构造函数会被调用（被编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作：</p>
<ul>
<li><p>调用所有虚基类的构造函数，从左到右，从最深到最浅：</p>
<ul>
<li>如果该类被列于成员初始化列表中，任何明确明确指定的参数，都应该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构造函数被调用（有的话）。</li>
<li>此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现虚基类的编译器来说，满足这点要求就是对vbptr的初始化。</li>
<li>然而，只有在类对象代表着“most-derived class”时，这些构造函数才可能会被调用。一些支持这个行为的代码会被放进去^注2（直观点说就是，虚基类的构造由最外层类控制)。</li>
</ul>
</li>
<li><p>调用所有基类构造函数，依声明顺序：</p>
<ul>
<li>如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该被传递过来。</li>
<li>没有列入的话，那么调用其默认构造函数，如果有的话。</li>
<li>如果该基类是第二顺位或之后的基类，this 指针必须被调整。</li>
</ul>
</li>
<li><p>正确初始化vptr,如果有的话。</p>
</li>
<li>调用没有出现在初始化成员列表中的member object的默认构造函数，如果有的话。</li>
<li>记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函数中。</li>
</ul>
<h4 id="虚拟继承下的构造抑制"><a href="#虚拟继承下的构造抑制" class="headerlink" title="虚拟继承下的构造抑制"></a>虚拟继承下的构造抑制</h4><p>有如下继承体系：</p>
<p><img src="/images/cpp/cpp_10.png" alt=""></p>
<p>根据c++ 语法，Point 的初始化应有most-derived class来施行。也就是说当Vertex3d为most-derived class的时候，应当由它的构造函数来调用Point的构造函数初始化Point子对象，Vertex3d的子对象的构造函数对于Point的调用则应当抑制。如果没有抑制会怎么样?当我们定义Vertex3d cv;时，Vertex3d的构造函数中调用Point的构造函数、而随之调用它的子对象，Point3d和Vertex的<br>构造函数中也调用了Point的构造函数。先不说，对于同一个子对象进行三次初始化是否有效率，更重要的是，这将不可避免的带来错误。由Vertex3d指定的子对象Point的值，会被覆盖掉。</p>
<p>编译器通常使用一个条件变量来表示是否为most-derived class,各构造函数根据这个条件变量来决定是否调用虚基类的构造函数，因此通过控制这个条件变量，就可以抑制非most-derived class调用虚基类的构造函数。当然也有其它的方法来做同样的事。</p>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><p>设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：</p>
<ul>
<li>什么都不做，采用编译器提供默认行为（bitwise copy或者由编译器合成一个）。</li>
<li>自己提供一个赋值运算符操作。</li>
<li>明确拒绝将一个对象指定给另一个对象。<br>对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。对于第二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时候。</li>
</ul>
<p>以下四种情况 copy assignment operator(还是用它的英文名，感觉顺畅点)，不具有bitwise copy语意，也就是说这些情况下，编译器要合成copy assignmentoperator而不能依靠bitwise copy来完成赋值操作，这四种情况与构造函数、拷贝构造函数的情况类似，原因可以参考它们的。四种情况如下：</p>
<ul>
<li>类包含有定义了copy assignment operator的class object成员。</li>
<li>类的基类有copy assignment operator。</li>
<li>类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝的时候）。</li>
<li>当class继承体系中有虚基类时。<br>在虚拟继承情况下，copy assignment opertator会遇到一个不可避免的问题，virtual base class subobject的复制行为会发生多次，与前面说到的在虚拟继承情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derivedclass 对virtual base class 的赋值行为。</li>
</ul>
<p>安全的做法是把虚基类的赋值放在最后，避免被覆盖。</p>
<h3 id="对象析构语意学"><a href="#对象析构语意学" class="headerlink" title="对象析构语意学"></a>对象析构语意学</h3><p>只有在基类拥有析构函数，或者object member拥有析构函数的时候，编译器才为类合成析构函数，否则都被视为不需要。</p>
<p>析构的顺序正好与构造相反：</p>
<ul>
<li>本身的析构函数被执行。</li>
<li>以声明的相反顺序调用member object 的析构函数，如果有的话。</li>
<li>重设vptr 指向适当的基类的虚函数表，如果有的话。</li>
<li>以声明相反的顺序调用上一层的析构函数，如果有的话。</li>
<li>如果当前类是 most-derivedclass，那么以构造的相反顺序调用虚基类的析构函数。</li>
</ul>
<p>“在此之前”的叙述并不适合我，我喜欢很直白的方式，按顺序来。书中的方式在于，从最浅显的步骤入手，然后告诉你，做这步之前，你还该做点什么。所以，我以对原文的理解写下这点。Lippman的原文为：</p>
<blockquote>
<p>These constructors, however, may be invoked if, and only if, the class object represents the “most-derived class.” Some mechanism supporting this must be put into place.</p>
</blockquote>
<p>侯捷的译文为：</p>
<blockquote>
<p>如果class object是最底层（most-derived）的class,其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。</p>
</blockquote>
<p>我认为，Lippman在这一句上要说的是，虚基类的构造函数只能由most-derived class调用，而为了支持这一机制，需要插入一些代码来抑制非most-derived class对虚基类构造函数的调用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/执行期语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/执行期语意学/" itemprop="url">执行期语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T20:27:34+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="new-expression、operator-new-和-placement-new"><a href="#new-expression、operator-new-和-placement-new" class="headerlink" title="new expression、operator new 和 placement new"></a>new expression、operator new 和 placement new</h2><p>之前虽然一直知道有new expression、operator new和placement new，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new和delete，特意结合《C++ Primer》写下这篇笔记，以作总结。三个虽然都是new，但每个new都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个“new”，但期间也不忘提一提推倒这三个“new”的哥们——delete。</p>
<p>new expression 和 operator new</p>
<p>一个看起来很简单的new expression运算，其实暗含一些步骤，像这样的一次简单运用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *p=new int (5)实际上包含着两个步骤：</div></pre></td></tr></table></figure></p>
<ul>
<li>调用一个合适的operator new实体分配足够的未类型化的内存。</li>
<li>调用合适的构造函数初始化这块内存，当然int没有构造函数，但是会进行赋值操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*p=5。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可见：new expression和operator new完全不是一回事，但关系不浅——operator new 为new expression分配内存。</p>
<p>摘录一下 《C++ primer》关于对比new expression 和 operator new的一小段话：</p>
<blockquote>
<p>标准库函数 operator new和 operator delete 的命名容易让人误解。与其他operator 函数（如 operator=）不同，这些函数没有重载new或delete expression，实际上，我们不能重定义new或delete expression的行为。</p>
</blockquote>
<p>这段话有两个要点：</p>
<ul>
<li>operator new和operator delete不是new expression和delete expression的重载，它们完全是另外的一个独立的东西，具有不同的语意，这与operator +是对+ expression的重载不同。</li>
<li>new expression和delete expression是不能被重载的，可以看出它们与普通的expression 不同。</li>
<li>operator new其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用operator new 来进行。用法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T* newelements = static_cast&lt;T*&gt;(operator new ( sizeof(T) );</div></pre></td></tr></table></figure>
<p>标准库重载有两个版本的operator new，分别为单个对象和数组对象服务，单个对象版本的<br>提供给分配单个对象new expression调用，数组版的提供给分配数组的 new expression 调<br>用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void *operator new(size_t);       // allocate an object</div><div class="line">void *operator new[](size_t);     // allocate an array</div></pre></td></tr></table></figure></p>
<p>我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operator new时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个void*类型和第一个参数的类型必须为size_t。</p>
<p>还要注意的是，在类中重载的operator new和operator delete是隐式静态的，因为前者运行于对象构造之前，后者运行与对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据。另外，new expression 默认调用的是单参数的operator new——上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p>
<p>delete expression与new expression相对应，而operator delete则与operator new对应。<br>依上所述，则不难推断出关于delete expression和operator delete之间的关系以及一些特性，此略。</p>
<p>当使用new expression来动态分配数组的时候，Lippman在《深度探索C++对象模型》中指出：</p>
<ul>
<li>当分配的类型有一个默认构造函数的时候，new expression将调用一个所谓的vec_new()函数来分配内存，而不是operator new内存。但我在VC ++ 20102上测试的结果却是，不论有没有构造函数，new expression都是调用operator new来分配内存，并在此之后，调用默认构造函数逐个初始化它们，而不调用所谓的vec_new()，也许cfront确实离我们有点遥远。</li>
</ul>
<h2 id="两个-delete-后的问题"><a href="#两个-delete-后的问题" class="headerlink" title="两个 delete 后的问题"></a>两个 delete 后的问题</h2><p>最近在网上看到两个关于指针 delete 后的问题。第一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int;</div><div class="line">delete p;</div><div class="line">delete p;// p为什么能delete两次，而程序运行的时候还不报错。</div></pre></td></tr></table></figure></p>
<p>第二种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int ;</div><div class="line">delete p;</div><div class="line">*p = 5;     //delete后对*p进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？</div></pre></td></tr></table></figure></p>
<p>在回答这两个问题之前，我们先想想delete p; 这一语句意味着什么？p指向一个地址，以该地址为起始地址保存有一个int变量（虽然该变量并没有进行初始化），delete p之后p所指向的地址空间被释放，也就是说这个int变量的生命结束，但是p仍旧是一个合法的指针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与delete之前唯一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？你租了一间储物室（int* p = new int;），后来退租了（delete p;），但你却保存了出入该储物室的钥匙（指针p）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。<br>但是：你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这<br>个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再之后各种难以预料的情况就会发生。</p>
<p>又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾出空间来放你的。</p>
<p>回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大<br>的逻辑错误，不论你对一块已经释放的内存再度delete，还是再度给它赋值，都暗含着很大<br>的危险，因为当你delete后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再<br>度分配出去，此时不论是你再度delete还是重新赋值，都将破坏其它代码的数据，同时你存<br>储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，这取决于有一个怎么样的“房东”，<br>聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。</p>
<p>上述情况下的指针p被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的<br>内存。避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为NULL，其缘由在<br>于，你可以很容易的判断一个指针是否为NULL,却难以抉择其是否为野指针。而且，delete<br>一个空指针，不会做任何操作，因此总是安全的。</p>
<h2 id="不用一个基类指针指向派生类数组？"><a href="#不用一个基类指针指向派生类数组？" class="headerlink" title="不用一个基类指针指向派生类数组？"></a>不用一个基类指针指向派生类数组？</h2><p>《深度探索C++对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的cfront中的vec_delete是根据被删除指针的类型来调用析构函数——也就是说虚函数机制在这儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。我在vc++2008和vc++ 2010下的结果是：是的，有与cfront不同，它支持多态。</p>
<p>我的测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class point&#123;</div><div class="line">public:</div><div class="line">        virtual ~point()&#123;</div><div class="line">            std::cout&lt;&lt;&quot;point::~point()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int  a;</div><div class="line">&#125;;</div><div class="line">class point3d:public point&#123;</div><div class="line">public:</div><div class="line">    virtual ~point3d()</div><div class="line">        &#123;</div><div class="line">            std::cout&lt;&lt;&quot;point3d::~point3d()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int b;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    point *p=new point3d[2];</div><div class="line">    delete[] p;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">&#125; ;</div></pre></td></tr></table></figure>
<p>输出的结果，也令人满意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div></pre></td></tr></table></figure>
<p>确实调用了派生类的析构函数，而非基类的析构函数。</p>
<p>即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。非得这么做？那么我认为delete的时候将之类类型转换为派生类就差不多了，可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete[] static_cast&lt;point3d*&gt;(p);</div></pre></td></tr></table></figure>
<p>似乎不必要像Lippman说的这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( int ix = 0; ix &lt; elem_count; ++ix ) </div><div class="line">&#123;  </div><div class="line">    Point3d *p = &amp;((Point3d*)ptr)[ ix ];  </div><div class="line">    delete p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="placement-operator-new"><a href="#placement-operator-new" class="headerlink" title="placement operator new"></a>placement operator new</h2><p>placement operator new用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是对指定地址调用构造函数。其调用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point3d;</div></pre></td></tr></table></figure></p>
<p>观其名字可知，它是operator new的一个重载版本。它的实现方式异常简单，传回一个指针即 可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void* operator new(site_t,void *p)</div><div class="line">&#123;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman告诉我们，它有另一半重要的工作是被扩充而来。我在想，扩充一个类中定义的placement operator new还好说，但是要如何 扩充一个库中提供的placement operator new呢？毕竟它要放之四海而皆准，我原以为这其中 有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement operator new 也并不强 大。</p>
<p>我先明确调用了 placement operator new ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=(point*)operator new(sizeof(point), p) ;</div></pre></td></tr></table></figure></p>
<p>如我所料，输出结果显示（我在point的默认构造函数和placement operator new中间各输 出一句不同的话），此时 point的默认构造函数并不会被调用。然后我通过new expression 的方式来间接调用placement operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point();</div></pre></td></tr></table></figure></p>
<p>这个时候 point 的默认的构造函数被调用了。可见 placement operator new并没有什么奇特 的地方，它与一般的operator new不同处在于，它不会申请内存。它也不会在指定的地址调用 构造函数，而调用构造函数的的全部原因在于new expression总是先调用一个匹配参数的 operator new然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new 也是一个operator new。</p>
<p>通过一个placement operator new构建的一个对象，如果你使用delete来撤销对象，那么其内 存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。</p>
<p>看一份代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Base &#123; int j; virtual void f(); &#125;;</div><div class="line">struct Derived : Base &#123; void f(); &#125;;</div><div class="line">void fooBar() &#123;  </div><div class="line">   Base b;  </div><div class="line">   b.f(); // Base::f() invoked  </div><div class="line">   b.~Base();  </div><div class="line">   new ( &amp;b ) Derived; // 1  </div><div class="line">   b.f(); // which f() invoked?  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述两个类的大小相同，因此将Derived对象放在 Base对象中是安全的，但是在最后一句代码 中 b.f()调用的是哪一个类的f()。答案是Base::f() 的。虽然此时b中存储的实际上是一个 Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。</p>
<p>参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/Function语意学（The-Semantics-of-Function）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/Function语意学（The-Semantics-of-Function）/" itemprop="url">Function语意学（The Semantics of Function）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T23:23:39+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-之成员函数调用"><a href="#C-之成员函数调用" class="headerlink" title="C++之成员函数调用"></a>C++之成员函数调用</h2><p>c++支持三种类型的成员函数，分别为<code>static</code>,<code>nostatic</code>,<code>virtual</code>。每一种调用方式都不尽相同。</p>
<h3 id="非静态成员函数（Nonstatic-Member-Functions）"><a href="#非静态成员函数（Nonstatic-Member-Functions）" class="headerlink" title="非静态成员函数（Nonstatic Member Functions）"></a>非静态成员函数（Nonstatic Member Functions）</h3><p>保证nostatic member function至少必须和一般的nonmember function有相同的效率是C++的设计准则之一。事实上在c++中非静态成员函数（nostatic member function）与普通函数的调用也确实具有相同的效率，因为本质上非静态成员函数就如同一个普通函数,如一个非静态成员函数Xfloat Point::X();就相当于一个普通函数float X(Point* this);。编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p>
<ul>
<li>改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">float Point::X();</div><div class="line">//成员函数X被插入额外参数this</div><div class="line">float Point:: X(Point* this );</div><div class="line">当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</div></pre></td></tr></table></figure>
<ul>
<li><p>将每一个对非静态数据成员的操作都改写为经过this操作。</p>
</li>
<li><p>将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p>
</li>
</ul>
<p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p>
<p>由此可以做出一点总结：一个成员函数实际上就是一个被插入了一个接受其类的指针类型的额外参数的非成员函数，当然还要额外对函数的名称进行处理。额外插入的参数用来访问数据成员，而名称的特殊处理用来避免名字冲突。</p>
<p>对于名称的特殊处理并没有统一的标准，各大编译器厂商可能有不同的处理规则。在VC下上述的成员函数X()的名称X处理后就成了<code>?X@Point@@QAEMXZ</code>更多信息可以参见维基百科的Visual C++名字修饰。</p>
<p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//p-&gt;X();被转化为</div><div class="line">?X@Point@@QAEMXZ(p);</div><div class="line">//obj.X();被转化为</div><div class="line">?X@Point@@QAEMXZ(&amp;obj);</div></pre></td></tr></table></figure>
<h3 id="虚拟成员函数-Virtual-Member-Functions"><a href="#虚拟成员函数-Virtual-Member-Functions" class="headerlink" title="虚拟成员函数(Virtual Member Functions)"></a>虚拟成员函数(Virtual Member Functions)</h3><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// p-&gt;function()</div><div class="line">//将转化为</div><div class="line">(*p-&gt;vptr[1])(p);</div></pre></td></tr></table></figure>
<ul>
<li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li>
<li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().<br>何时发生这种转换？答案是在必需的时候——一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。</li>
</ul>
<h3 id="静态成员函数-Static-Member-Functions"><a href="#静态成员函数-Static-Member-Functions" class="headerlink" title="静态成员函数(Static Member Functions)"></a>静态成员函数(Static Member Functions)</h3><p>静态成员函数的一些特性：</p>
<ul>
<li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li>
<li>不能够声明为 const、voliatile或virtual。</li>
<li>它不需经由对象调用，当然，通过对象调用也被允许。<br>除了缺乏一个this指针他与非静态成员函数没有太大的差别。在这里通过对象调用和通过指针或引用调用，将被转化为同样的调用代码。</li>
</ul>
<p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(a+=b).static_fuc();</div></pre></td></tr></table></figure>
<p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间。这无疑是一个明智的规定。</p>
<h2 id="C-之虚函数-Virtual-Member-Functions"><a href="#C-之虚函数-Virtual-Member-Functions" class="headerlink" title="C++之虚函数(Virtual Member Functions)"></a>C++之虚函数(Virtual Member Functions)</h2><p>《深度探索C++对象模型》是这样来说多态的:</p>
<p>在C++中,多态表示“以一个public base<br>class的指针（或引用），寻址出一个derived class object”的意思。</p>
<h3 id="消极多态与积极多态"><a href="#消极多态与积极多态" class="headerlink" title="消极多态与积极多态"></a>消极多态与积极多态</h3><p>用基类指针来寻址继承类的对象，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point ptr=new Point3d;               //Point3d继承自Point</div></pre></td></tr></table></figure>
<p>在这种情况下，多态可以在编译期完成（虚基类情况除外），因此被称作消极多态（没有进行虚函数的调用）。相对于消极多态，则有积极多态——指向的对象类型需要在执行期在能决定。积极多态的例子如虚函数和RTTI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//例1，虚函数的调用</div><div class="line">ptr-&gt;z();</div><div class="line">//例2，RTTI 的应用</div><div class="line">if(Point3d *p=dynamic_cast&lt;Point3d*&gt;(ptr) )</div><div class="line">	return p-&gt;z();</div></pre></td></tr></table></figure>
<p>关于RTTI的笔记可见笔记EH &amp; RTTI。本文主要精力将集中于虚函数上。对于一个如上例关于虚函数的调用，要如何来保证在执行期调用的是正确的z()实体——Point3d::z()而不是调用了Point::z()。来看看虚函数的实现机制吧，它将保证这一点。</p>
<h3 id="单继承下的虚函数"><a href="#单继承下的虚函数" class="headerlink" title="单继承下的虚函数"></a>单继承下的虚函数</h3><p>虚函数的实现：</p>
<ul>
<li>为每个有虚函数的类配一张虚函数表，它存储该类类型信息和所有虚函数执行期的地址。</li>
<li>为每个有虚函数的类插入一个指针（vptr）,这个指针指向该类的虚函数表。</li>
<li>给每一个虚函数指派一个在表中的索引。<br>用这种模型来实现虚函数得益于在C++中,虚函数的地址在编译期是可知的，而且这一地址是固定不变的。而且表的大小不会在执行期增大或减小。</li>
</ul>
<p>一个类的虚函数表中存储有类型信息（存储在索引为0的位置）和所有虚函数地址，这些虚函数地址包括三种：</p>
<ul>
<li>这个类定义的虚函数，会改写（overriding）一个可能存在的基类的虚函数实体——假如基类也定义有这个虚函数。</li>
<li>继承自基类的虚函数实体，——基类定义有，而这个类却没有定义。直接继承之。</li>
<li>一个纯虚函数实体。用来在虚函数表中占座，有时候也可以当做执行期异常处理函数。<br>每一个虚函数都被指派一个固定的索引值，这个索引值在整个继承体系中保持前后关联，例如,假如z()在Point虚函数表中的索引值为2，那么在Point3d虚函数表中的索引值也为2。</li>
</ul>
<p>当一个类单继承自有虚函数的基类的时候，将按如下步骤构建虚函数表：</p>
<ul>
<li>继承基类中声明的虚函数——这些虚函数的实体地址被拷贝到继承类中的虚函数表中对于的slot中。</li>
<li>如果有改写（override）基类的虚函数，那么在1中应将改写（override）的函数实体的地址放入对应的slot中而不是拷贝基类的。</li>
<li>如果有定义新的虚函数，那么将虚函数表扩大一个slot以存放新的函数实体地址。<br>我们假设z()函数在Point虚函数表中的索引为4，回到最初的问题——要如何来保证在执行期调用的是正确的z()实体？其中微妙在于，编译将做一个小小的转换:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;z();</div><div class="line">//被编译器转化为：</div><div class="line">(*ptr-&gt;vptr[4])(ptr);</div></pre></td></tr></table></figure>
<p>这个转换保证了调用到正确的实体，因为：</p>
<ul>
<li>虽然我们不知道ptr所指的真正类型,但它可以通过vptr找到正确类型的虚函数表。</li>
<li>在整个继承体系中z()的地址总是被放在slot 4。</li>
</ul>
<h3 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h3><p>在多重继承下，继承类需要为每一条继承线路维护一个虚函数表（也有可能这些表被合成为一个，但本质意义并没有变化）。当然这一切都发生在需要的情况下。</p>
<p>当使用第一继承的基类指针来调用继承类的虚函数的时候，与单继承的情况没有什么异样，问题出生在当以第二或后继的基类指针（或引用）的使用上。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//假设有这样的继承关系：class Derived:public base1,public base2;</div><div class="line">//base1,base2都定义有虚析构函数。</div><div class="line">base2 *ptr = new derived;</div><div class="line">//需要被转换为，这个转换在编译期完成</div><div class="line">base2 *ptr = temp ? temp + sizeof(base1) : 0 ;</div></pre></td></tr></table></figure>
<p>如果不做出上面的转换，那么 ptr 指向的并不是 derived 的 base2 subobject。后果是，ptr 将一个derived类型当做base2类型来用。</p>
<p>当要delete ptr时又面临了一次转换，因为在delete ptr的时候，需要对整个对象而不是其子对象施行delete运算符，这期间需要调整ptr指向完整的对象起点，因为不论是调用正确的析构函数还是delete运算符都需要一个指向对象起点的指针，想一想给予一个derived类的成员函数指向base2 subobjuect 的this指针会发生什么吧。因为ptr的具体类型并不知道，所以必须要等到执行期来完成。</p>
<p>Bjame的解决方法是将每一个虚函数表的slot扩展，以使之存放一个额外的偏移量。于是虚函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(*ptr-&gt;vptr[1])(ptr);</div><div class="line">//将变成：</div><div class="line">(*ptr-&gt;vptr[1].addr)(ptr+*ptr-&gt;vptr[1].offset);</div></pre></td></tr></table></figure></p>
<p>其中使用ptr-&gt;vptr[1].addr用以获取正确的虚函数地址，而ptr+*ptr-&gt;vptr[1].offset来获得指向对象完整的起点。这种方法的缺点显而易见，代价过大了一点，所有的情况都被这一种占比较小的情况拖累。</p>
<p>还有一种叫做thunk的方法，thunk的作用在于:</p>
<ul>
<li>以适当的offset值来this调整指针.</li>
<li>跳到虚函数中去。</li>
</ul>
<p>Thunk技术即是：虚函数表中的slot仍然继续放一个虚函数实体地址，但是如果调用这个虚函数需要进行this调整的话,该slot中的地址就指向一个Thunk而不是一个虚函数实体的地址。</p>
<p>书中纷杂的讲到不少中种情况，但我以我的理解，做如下小结：</p>
<p>多继承下的虚函数，影响到虚函数的调用的实际质上为this的调整。而this调整一般为两种：</p>
<ul>
<li>调整指针指向对应的subobject，一般发生在继承类类型指针向基类类型指针赋值的情况下。</li>
<li>将指向subobject的指针调整回继承类对象的起始点，一般发生在基类指针对继承类虚函数进行调用的时候。</li>
</ul>
<p>第一点，使得该基类指针指向一个与其指针类型匹配的子对象，唯有如此才能保证使得该指针在执行与其指针类型相匹配的特定行为的正确性。比方调用基类的成员，获得正确的虚函数地址。可以想象如果不调整，用ptr存取base2 subobject的数据成员时，会发生什么？调用base2的成员函数的时候，其成员函数接受的this指针指向derived类型对象，这又会发生什么？结果是整个对象的内存结构有可能都被破坏。还有别忘了，vptr也可以看做一个数据成员，要找到虚函数，前提是获取正确的vptr偏移量。</p>
<p>而第二点，显然是让一个继承类的虚函数获取一个正确的this指针，因为一个继承类虚函数要的是一个指向继承类对象的this指针，而不是指向其子对象。</p>
<p>第一顺序继承类之所以不需要进行调整的关键在于，其subobject的起点与继承类对象的起点一致。</p>
<h3 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h3><p>Lippman说，如果一个虚基类派生自另一虚基类，而且它们都支持虚函数和非静态数据成员的时候，编译器对虚基类的支持就像迷宫一样复杂。</p>
<p>虽然书中没有介绍太多，但不难猜测的是在虚继承情况下，复杂点在仍旧在于this指针的调整，然而其复杂度显然又在多继承之上，因为又多了一个vbptr了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/03/vim使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/03/vim使用/" itemprop="url">vim使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-03T01:57:49+08:00">
                2015-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h3><ul>
<li><p>移动模式。文档上叫normal模式，ESC：从其它模式退出，进入移动模式，最好按两下</p>
</li>
<li><p>编辑模式。文档上叫insert模式。进入编辑模式有几种方式，适应用不同的场景，都是方便操作的，各按键如下：</p>
<ul>
<li>i ：在光标当前位置前进入</li>
<li>a：在光标当前位置后进入</li>
<li>shift + i：在行首位置进入</li>
<li>shfit + a：在行尾位置进入</li>
<li>o：在光标所在行下方新开一行进入</li>
<li>shift + o：在光标所在行上方新开一行进入</li>
</ul>
</li>
<li><p>选择模式。文档上叫什么忘了，不过选择也很好理解。选择模式有两种：</p>
</li>
<li>进入选择文本模式。从当前光标位置开始，移动光标，之间的文本都会是选中状态。这期间，可以使用移动光标的操作进行移动。</li>
<li>ctrl + v：进行特殊操作模式。也是我取的名字，原来叫块操作模式，什么是块？无法理解。它最有用的操作是给多行加上统一的首或尾，如：可以在选中的所有行首加上注释符，也可以在选中的所有行尾加上分号等。同样可以使用移动中的到行首或是到行尾进行操作。</li>
</ul>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul>
<li>行间移动<ul>
<li>j：下移一行</li>
<li>k：上移一行</li>
<li>gg：移到文档第一行</li>
<li>shift + g：移到文档最后一行</li>
<li>shift + h：移到当前屏的第一行</li>
<li>shift + m：移到当前屏的中间行</li>
<li>shift + l：移到当前屏的尾行</li>
<li>:行号：移到对应行号的行</li>
<li>ctrl + d：向下翻页</li>
<li>ctrl + u：向上翻页</li>
</ul>
</li>
</ul>
<p>当前屏：就是vim中显示出来的部分，未显示出来的部分不算在里，它里面上中下位置的移动，也就是在看得见的部分进行。</p>
<p>：行号：这个操作可以分三部分：</p>
<pre><code>shift + : 进入输入模式。
输入行号。
回车。
</code></pre><p>光标就会跳到输入行号的行上。</p>
<ul>
<li><p>行内移动（都是小写字母）</p>
<ul>
<li>h：左移一位</li>
<li>l：右移一位</li>
<li>w：跳到下一个词的词首</li>
<li>e：跳到当前词的词尾</li>
<li>b：跳到当前词的词首，如果光标本身就在当前词的词首，则跳到前一词的词首</li>
<li>shfit + ^：跳到行首（非空白字符）</li>
<li>shift + $：跳到行尾</li>
<li>f字符：跳到下一个相同字符的位置。之后按;可以继续跳向下一个相同字符的位置</li>
<li>shift + f字符：跳到上一个相同字符的位置。同上，之后按;可以继续跳向下一个相同字符的位置，只是方向和上面是相反的。</li>
</ul>
</li>
</ul>
<p>f字符：操作分两步：</p>
<pre><code>按f
按一个字符
</code></pre><p>这样光标会直接跳到当前光标之后对应按的字符的第一个出现位置，举个例子：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my name is onlyfu.</div></pre></td></tr></table></figure>
<p>当标在第一个字符m上，这时先按f，再按o，光标就会跳到o的位置。如果按f后按n，光标就会跳到之后出现的第一个n的位置，也就是name的n上，这是如果按;，光标就会跳到第二个n，也就是onlyfu的n上，;可以继续点，如果还有n就会继续跳过去。</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>复制一行<ul>
<li>yy：复制光标所在行 </li>
</ul>
</li>
<li>复制多行<ul>
<li>yj：复制光标当前行和其下一行，共两行</li>
<li>yk：复制光标当前行和其上一行，共两行</li>
<li>y:行号：复制渔村当前行到对应行号之间包括对应行号行，共多行</li>
</ul>
</li>
</ul>
<p>其实用得多的只有yy，复制多行同样可以使用复制选中内容的操作来实现</p>
<ul>
<li>复制选中内容<br>v移动光标y：复制选中的内容。这其实是三步操作：<ul>
<li>按v键，进入选择模式</li>
<li>移动光标，使用移动的方法来移动，行间，行内的操作都是可以的</li>
<li>按y键，复制所有选中内容，并进入移动模式</li>
</ul>
</li>
</ul>
<h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><ul>
<li>p：将复制内容粘贴出来。粘贴有两种情况：<ul>
<li>如果是整行的复制，粘贴会在当前光标行的下一行粘贴出来，这样会把之前的下面所有行顺序的往下移</li>
<li>如果复制的不是整行，只是行内或行间字符，粘贴会在妆前光标位置直接插入复制内容，不会新建行。</li>
</ul>
</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除和复制是同理的</p>
<ul>
<li>删除一行</li>
</ul>
<p>dd：删除光标所在行 </p>
<ul>
<li><p>删除多行</p>
<ul>
<li>dj：删除光标所在行及其下一行，共两行</li>
<li>dk：删除光标所在行及其上一行，共两行</li>
<li>d:行号d：删除光标所在行及对应行号之间，包括对应行号的所有行，共多行</li>
</ul>
</li>
</ul>
<p>注意，删除操作，会同时复制被删除的内容，这样就可以有移动行的操作，比如，想把第3行移到第5行，那就先删除第3行，到第4行上按粘贴。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/22/Linux中C-实现通用读取目录文件代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/22/Linux中C-实现通用读取目录文件代码/" itemprop="url">Linux中C++实现通用读取目录文件代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-22T23:47:17+08:00">
                2015-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux中C++实现通用读取目录文件代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;dirent.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void createDocList(std::vector&lt;std::string&gt; &amp;doc_list)&#123;</div><div class="line">    int return_code;</div><div class="line">    DIR *dir;</div><div class="line">    struct dirent entry;</div><div class="line">    struct dirent *res;</div><div class="line">    string real_dir = &quot;/helloyou/home/&quot;;//搜索的目录</div><div class="line">    if ((dir = opendir(real_dir.c_str())) != NULL) &#123;//打开目录</div><div class="line">        for (return_code = readdir_r(dir, &amp;entry, &amp;res);res != NULL &amp;&amp; return_code == 0;return_code = readdir_r(dir, &amp;entry, &amp;res)) &#123;</div><div class="line">            if (entry.d_type != DT_DIR) &#123;//存放到列表中</div><div class="line">                doc_list.push_back(string(entry.d_name));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        closedir(dir);//关闭目录</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/02/Data语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/02/Data语意学/" itemprop="url">Data 语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-02T23:03:46+08:00">
                2015-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-类对象的大小"><a href="#C-类对象的大小" class="headerlink" title="C++类对象的大小"></a>C++类对象的大小</h2><h3 id="一个实例引出的思考"><a href="#一个实例引出的思考" class="headerlink" title="一个实例引出的思考"></a>一个实例引出的思考</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;&#125;;</div><div class="line">class Y:virtual public X&#123;&#125;;</div><div class="line">class Z:virtual public X&#123;&#125;;</div><div class="line">class A:public Y, public Z&#123;&#125;;</div></pre></td></tr></table></figure>
<p>猜猜sizeof上面各个类都为多少？</p>
<p>Lippman的一个法国读者的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof X yielded 1                         </div><div class="line">sizeof Y yielded 8                         </div><div class="line">sizeof Z yielded 8                         </div><div class="line">sizeof A yielded 12</div></pre></td></tr></table></figure></p>
<p>我在vs2012上的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof X yielded 1   </div><div class="line">sizeof Y yielded 4   </div><div class="line">sizeof Z yielded 4    </div><div class="line">sizeof Z yielded 8</div></pre></td></tr></table></figure></p>
<p>当我们对于C++对象的内存布局知之甚少的情况下，想搞清这些奇怪现象的缘由将是一件非常困难的事情。不过下文会为你一一解惑。</p>
<p>事实上，对于像X这样的一个的空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p>
<p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p>
<p>alignment[^注1]会将数值调整到某数的整数倍，32位计算机上位4bytes。内存对齐可以使得总线的运输量达到最高效率。所以Y、Z的大小被补齐到8就不足为奇了。</p>
<p>那么在vs2012中为什么Y、Z的大小是4而不是8呢？我们先思考一个问题，X之所以被插入1字节是因为本身为空，需要这一个字节为其在内存中给它占领一个独一无二的地址。但是当这一字节被继承到Y、Z后呢？它已经完全失去了它存在的意义，为什么？因为Y、Z各自拥有一个虚基类指针，它们的大小不是0。既然这一字节在Y、Z中毫无意义，那么就没必要留着。也就是说vs2010对它们进行了优化，优化的结果是去掉了那一个字节,而Lippman的法国读者的编译器显然没有做到这一点。</p>
<p>当我们现在再来看A的时候，一切就不是问题了。对于那位Lippman的法国读者来说，A的大小是共享的X实体1字节,X和Y的大小分别减去虚基类带来的内存空间，都是4。A的总计大小为9，alignment以后就是12了。而对于vs2010来说，那个一字节被优化后，A的大小为8，也不需再进行alignment操作。</p>
<h3 id="影响C-类的大小的三个因素："><a href="#影响C-类的大小的三个因素：" class="headerlink" title="影响C++类的大小的三个因素："></a>影响C++类的大小的三个因素：</h3><ul>
<li>支持特殊功能所带来的额外负担（对各种virtual的支持）。</li>
<li>编译器对特殊情况的优化处理。</li>
<li>alignment操作，即内存对齐。[关于更多的memory alignment（内存对齐）的知识见VC内存对齐准则（Memory alignment）]</li>
</ul>
<h2 id="VC内存对齐准则（Memory-alignment）"><a href="#VC内存对齐准则（Memory-alignment）" class="headerlink" title="VC内存对齐准则（Memory alignment）"></a>VC内存对齐准则（Memory alignment）</h2><p>本节所有内容在建立在一个前提下：使用VC编译器。着重点在于：VC的内存对齐准则；同样的数据，<br>不同的排列有不同的大小，另外在有虚函数或虚拟继承情况下又有如何影响？</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>对于一台32位的机器来说如何才能发挥它的最佳存取效率呢？当然是每次都读4字节（32bit）,这样才可以让它的bus处于最高效率。实际上它也是这么做的，即使你只需要一个字节，它也是读一个机器字长（这儿是32bit）。更重要的是，有的机器在存取或存储数据的时候它要求数据必须是对齐的，何谓对齐？它要求数据的地址从4的倍数开始，如若不然，它就报错。还有的机器它虽然不报错，但对于一个类似int变量，假如它横跨一个边界的两端，那么它将要进行两次读取才能获得这个int值。比方它存储在地址为2~5的四个字节中，那么要读取这个int，将要进行两次读取，第一次读取0~3四个字节，第二次读取4~7四个字节。但是如果我们把这个整形的起始地址调整到0,4,8…呢？一次存取就够了！这种调整就是内存对齐了。我们也可以依次类推到16位或64位的机器上。</p>
<h3 id="边界该如何调整"><a href="#边界该如何调整" class="headerlink" title="边界该如何调整"></a>边界该如何调整</h3><p>对于32位的机器来说，它当然最渴望它的数据的大小都是4 Byte或者4的倍数Byte，这样它就能最有效率的存取数据，当然如果数据小于4Byte,那也是没问题的。那么编译器要做的便是尽量满足这个要求。</p>
<p>这两天我断续对VC做了一些实验，并总结如下三条准则，你要明白的是这并非来自微软的官方文档，但我自以为这些准则或许不全但应该都是正确的：</p>
<ul>
<li>变量存放的起始位置^注2应为变量的大小与规定对齐量[^注1]中较小者的倍数。例如，假设规定对齐量为4，那么char（1byte）变量应该存储在偏移量为1的倍数的地方，而整形变量（4byte）则是从偏移量为4的倍数的地方，而double（8 byte）也同样应存储在偏移量为4的倍数的地方，为什么不是8？因为规定对齐量默认值为4，而4 &lt; 8。在VC中默认对齐量为8，而非4。</li>
<li>结构体整体的大小也应该对齐，对齐依照规定对齐量与最大数据成员两者中较小的进行。</li>
<li>Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响。一个实例</li>
</ul>
<p>对于类T：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class T &#123;</div><div class="line">    char c;</div><div class="line">    int i;</div><div class="line">    double  d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将其sizeof输出后的大小为16，其内存布局如图T.变量c从偏移量为0开始存储，而整形i第一个符号条件的偏移量为4，double型d的第一个符号条件的为8。整个对象的大小为16，不需要再进行额外的对齐。</p>
<p>类T 的内存布局<br><img src="/images/cpp/cpp_8.png" alt=""></p>
<p>同样的数据，不同的大小</p>
<p>再看类L,它与T存储同样类型的数据，仅仅是顺序不同罢了，那么它sizeof输出的大小是多少呢?</p>
<p>类L:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class L &#123;</div><div class="line">    char c;</div><div class="line">    double  d;</div><div class="line">    int i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它sizeof后的结果或许会令你大吃一惊，或许不会（如果你有认真读前面的两条准则）。Lsizeof后的结果是24！同样是一个int，一个char，一个double却整整多出了8个字节。这期间发生了什么？我们依据前面两条规则来看看。C存储于0的位置，1~7都不能整除8，所以d存储在8~15，16给i正好合适，i存储在16~19。总共花费了20个字节，抱歉不是8的倍数，还得补齐4个。现在你可以看看图L的关于类L的内存布局，再比较一下类L和类T的内存布局。</p>
<p>图L(类L的布局)<br><img src="/images/cpp/cpp_9.png" alt=""></p>
<p>我得出了这样一条并不权威的结论，因为我还没听有人这样说过：在声明数据成员的时候，将最大字节数的变量放在最前面[^注3],切忌不要将大小差距很大的类型交替声明。</p>
<h3 id="Vptr影响对齐而VbcPoint-Virtual-base-class-pointer-不影响"><a href="#Vptr影响对齐而VbcPoint-Virtual-base-class-pointer-不影响" class="headerlink" title="Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响"></a>Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响</h3><p>前面的实例只涉及前两条准则，现在我们来看看第三条的两个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class X&#123;char a;&#125;;</div><div class="line">class Y: virtual public X&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>Y的大小为:a占一个字节，VbcPoint（我称他为虚基类指针）占四个字节。我们不论a与VbcPoint的位置如何摆放，如果将VbcPoint等同于一个成员数据来看的话，sizeof(Y)都应该为8.实际上它是5！就我目前的水平，我只能先将其解释为VbcPoint不参与对齐。</p>
<p>对于vptr这个问题则不存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">    char a;</div><div class="line">    virtual int vfc()&#123;&#125;;&#125;</div><div class="line">sizeof（X）的大小确实为8.</div></pre></td></tr></table></figure>
<p>关于#pragma pack(n)</p>
<p>用#pragma pack(n)改变规定对齐量试试眨眼。</p>
<p>使我确信从大到小排列好于从小到大排列的理由在于，从大到小排列一般无需成员之间的对齐，唯一的对齐工作是最后进行的整个结构体对齐的工作。毫无疑问的是，这应该是最节省内存的方式。再之后，独酌提出从小到大可能好些，虽然没有给出有说服力的理由，但却使我无比困惑，我当时虽然认为从大到小的排列更有优势，但却实在想不出一个实例能使得它优于从小到大排列的。不过最终我击垮了自己的理由，在继承状况下从大到小排列很容易被打破，比方，基类的成员为一个char,继承类的成员为double,int,char虽然基类和继承类都是按从大到小的顺序排列的，但是继承类的内存布局最终会使char,double,int,char，此时既不能避免成员对齐，又导致后面的结构体对齐。暂时获得的最终结果是从小到大排列是更好的一种排列方式。</p>
<h2 id="C-对象的数据成员"><a href="#C-对象的数据成员" class="headerlink" title="C++对象的数据成员"></a>C++对象的数据成员</h2><h3 id="数据成员的布局"><a href="#数据成员的布局" class="headerlink" title="数据成员的布局"></a>数据成员的布局</h3><p>对于一个类来说它的对象中只存放非静态的数据成员,但是除此之外，编译器为了实现virtual功能还会合成一些其它成员插入到对象中。我们来看看这些成员的布局。</p>
<h3 id="C-标准的规定"><a href="#C-标准的规定" class="headerlink" title="C++ 标准的规定"></a>C++ 标准的规定</h3><ul>
<li>在同一个Access Section（也就是private,public,protected片段）中，要求较晚出现的数据成员处在较大的内存中。这意味着同一个片段中的数据成员并不需要紧密相连，编译器所做的成员对齐就是一个例子。</li>
<li>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。</li>
<li>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</li>
<li>对于虚基类成员也是同样的未予规定。</li>
</ul>
<h3 id="一般的编译器怎么做？"><a href="#一般的编译器怎么做？" class="headerlink" title="一般的编译器怎么做？"></a>一般的编译器怎么做？</h3><ul>
<li>同一个Access Section中的数据成员按期声明顺序，依次排列。</li>
<li>但成员与成员之间因为内存对齐的原因可能存在空当。</li>
<li>多个Access Section按其声明顺序排放。</li>
<li>基类的数据成员总放在自己的数据成员之前，但虚基类除外。</li>
</ul>
<h3 id="编译器合成的成员放在哪？"><a href="#编译器合成的成员放在哪？" class="headerlink" title="编译器合成的成员放在哪？"></a>编译器合成的成员放在哪？</h3><p>为了实现虚函数和虚拟继承两个功能，编译器一般会合成Vptr和Vbptr两个指针。那么这两个指针应该放在什么位置？C++标准肯定是不曾规定的，因为它甚至并没有规定如何来实现这两个功能，因此就语言层面来看是不存在这两个指针的。</p>
<p>对于Vptr来说有的编译器将它放在末尾，如Lippman领导开发的Cfront。有的则将其放在最前面，如MS的VC，但似乎没人将它放在中间。为什么不放在中间？没有理由可以让人这么做，放在末尾，可以保持C++类对C的struct的良好兼容性，放在最前可以给多重继承下的指针或引用调用虚函数带来好处。</p>
<p>看一小段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">public:</div><div class="line">    int a;</div><div class="line">    virtual void vfc()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    using namespace std;</div><div class="line">    X x;</div><div class="line">    cout&lt;&lt;&amp;x.a&lt;&lt;&quot; &quot;&lt;&lt;&amp;x&lt;&lt;endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在VS2010和VC6.0中运行的结果都是地址值&amp;x.a比&amp;x大4，可见说vc的vptr放在对象的最前面此言非虚。</p>
<p>对于Vbptr来说，有好几种方法，在这儿我们只看看VC的实现原理：</p>
<p>对于由虚拟继承而得的类，VC会在其每一个对象中插入一个Vbptr,这个Vbptr指向vitual base class table（我称之为虚基类表）。虚基类表中则存放有其虚基类子对象相对于虚基类指针的偏移量。例如声明如class Y:virtual public X的类的virtual base class table的虚基类表中当存储有X对象相对于Vbptr的偏移量。</p>
<p>对象成员或基类对象成员后面的填充空白不能为其它成员所用</p>
<p>看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">public:</div><div class="line">    int x;</div><div class="line">    char c;</div><div class="line">&#125;;</div><div class="line">class X2:public X</div><div class="line">&#123;</div><div class="line">public:char  c2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X2 x2;</div><div class="line">X x;</div><div class="line">x2=x;</div></pre></td></tr></table></figure>
<p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p>
<p>Vptr与Vbptr^注1</p>
<ul>
<li>在多继承情况下，即使是多虚拟继承，继承而得的类只需维护一个Vbptr；而多继承情况下Vptr则可能有要维护多个Vptr，视其基类有几个有虚函数。</li>
<li>一条继承线路只有一个Vptr，但可能有多个Vbptr，视有几次虚拟继承而定。换言之，对于一个继承类对象来说，不需要新合成vptr，而是使用其基类子对象的vptr。而对于一个虚拟继承类来说，必须新合成一个自己的Vbptr。<br>如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">    virtual void vf()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">class X2:virtual public X</div><div class="line">&#123;</div><div class="line">    virtual void vf()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">class X3:virtual public  X2</div><div class="line">&#123;</div><div class="line">     virtual void vf()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>X3将包含有一个Vptr，两个Vbptr。确切的说这两个Vbptr一个属于X3，一个属于X3的子对象X2,X3通过其Vbptr找到子对象X2，而X2通过其Vbptr找到X。</p>
<p>其中差别在于vptr通过一个虚函数表可以确切地知道要调用的函数，而Vbptr通过虚基类表只能够知道其虚基类子对象的偏移量。这两条规则是由虚函数与虚拟继承的实现方式，以及受它们的存取方式和复制控制的要求决定的。</p>
<h3 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h3><p>静态数据成员相当于一个仅对该类可见的全局变量，因为程序中只存在一个静态数据成员的实例，所以其地址在编译时就已经被决定。不论如何静态数据成员的存取不会带来任何额外负担。</p>
<p>非静态数据成员的存取，相当于对象起始地址加上偏移量。效率上与C struct成员的效率等同。因为它的偏移量在编译阶段已经确定。但有一种情况例外：pt-&gt;x=0.0。当通过指针或引用来存取——x而x又是虚基类的成员的时候。因为必须要等到执行期才能知道pt指向的确切类型，所以必须通过一个间接导引才能完成。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在VC中数据成员的布局顺序为：</p>
<ul>
<li>vptr部分（如果基类有，则继承基类的）</li>
<li>vbptr （如果需要）</li>
<li>基类成员（按声明顺序）</li>
<li>自身数据成员</li>
<li>虚基类数据成员（按声明顺序）</li>
</ul>
<h3 id="参考：《深度探索C-对象模型》"><a href="#参考：《深度探索C-对象模型》" class="headerlink" title="参考：《深度探索C++对象模型》"></a>参考：《深度探索C++对象模型》</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/构造函数语义学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/构造函数语义学/" itemprop="url">构造函数语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T23:27:07+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++构造函数"></a>C++构造函数</h2><p>通常很多C++程序员存在两种误解：</p>
<ul>
<li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li>
<li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li>
</ul>
<p>在读《深度探索C++对象模型》之前，我一直停留在上述二种误解上，所幸的是<br>Lippman为我破除了。下面的部分我将随《深度探索C++对象模型》对C++默<br>认构造函数一探究竟。</p>
<p>C++标准规定：如果类的设计者并未为类定义任何构造函数，那么会有一个默认<br>构造函数被暗中生成，而这个暗中生成的默认构造函数通常是不做什么事的(无<br>用的)，下面四种情况除外。</p>
<p>换句话说，<code>有以下四种情况编译器必须为未声明构造函数的类生成一个会做点事
的默认构造函数</code>。我们会看到这些默认构造函数仅“忠于编译器”，而可能不会按<br>照程序员的意愿程效命。</p>
<h3 id="包含有带默认构造函数的对象成员的类"><a href="#包含有带默认构造函数的对象成员的类" class="headerlink" title="包含有带默认构造函数的对象成员的类"></a>包含有带默认构造函数的对象成员的类</h3><p>若一个类X没有定义任何构造函数，但却包含一个或以上定义有默认构造函数的对象成员，此时编译器会为X合成默认构造函数，该默认函数会调用对象成员的默认构造函数为之初始化。如果对象的成员没有定义默认构造函数，那么编译器合成的默认构造函数将不会为之提供初始化。例如类A包含两个数据成员对象，分别为：string str和char <em>Cstr，那么编译器生成的默认构造函数将只提<br>供对string类型成员的初始化，而不会提供对char</em>类型的初始化。</p>
<p>假如类X的设计者为X定义了默认的构造函数来完成对str的初始化，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A::A()&#123;Cstr=”hello”&#125;</div></pre></td></tr></table></figure></p>
<p>因为默认构造函数已经定义，编译器将不能再生成一个默认构造函数。但是编译器将会扩充程序员定义的默认构造函数——在最前面插入对初始化str的代码。若有多个定义有默认构造函数的成员对象，那么这些成员对象的默认构造函数的调用将依据<code>声明顺序排列</code>。</p>
<h3 id="继承自带有默认构造函数的基类的类"><a href="#继承自带有默认构造函数的基类的类" class="headerlink" title="继承自带有默认构造函数的基类的类"></a>继承自带有默认构造函数的基类的类</h3><p>如果一个没有定义任何构造函数的类派生自带有默认构造函数的基类，那么编译器为它定义的默认构造函数，将按照声明顺序为之依次调用其基类的默认构造函数。若该类没有定义默认构造函数而定义了<code>多个其他构造函数</code>，那么编译器<code>扩充它的所有构造函数</code>——加入必要的基类默认构造函数。另外，编译器会将基类的默认构造函数代码加在对象成员的默认构造函数代码之前。</p>
<h3 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h3><p>带有虚函数的类，与其它类不太一样，因为它多了一个vptr，而vptr的设置是由编译器完成的，因此编译器会为类的<code>每个构造函数添加代码来完成对vptr的初始化</code>。</p>
<h3 id="带有一个虚基类的类"><a href="#带有一个虚基类的类" class="headerlink" title="带有一个虚基类的类"></a>带有一个虚基类的类</h3><p>在这种情况下，编译器要将虚基类在类中的位置准备妥当，提供支持虚基类的机制。也就是说要在所有构造函数中加入实现前述功能的的代码。没有构造函数将合成以完成上述工作。</p>
<p>总结：简单来讲编译器会为构造函数做的一点事就是调用其基类或成员对象的默认构造函数，以及初始化vprt以及准备虚基类的位置。</p>
<p>总的来说，编译器将对构造函数动这些手脚：</p>
<pre><code>- 如果类虚继承自基类，编译器将在所有构造函数中插入准备虚基类位置的代码和提供支持虚基类机制的代码。
- 如果类声明有虚函数，那么编译器将为之生成虚函数表以存储虚函数地址，并将虚函数指针（vptr）的初始化代码插入到类的所有构造函数中。
- 如果类的父类有默认构造函数，编译将会对所有的默认构造函数插入调用其父类必要的默认构造函数。必要是指设计者没有显示初始化其父类，调用顺序，依照其继承时声明顺序。
- 如果类包含带有默认构造函数的对象成员，那么编译器将会为所有的构造函数插入对这些对象成员的默认构造函数进行必要的调用代码，所谓必要是指类设计者设计的构造函数没有对对象成员进行显式初始化。成员对象默认构造函数的调用顺序，依照其声明顺序。
- 若类没有定义任何构造函数，编译器会为其合成默认构造函数，再执行上述四点。
</code></pre><p>需要说明的是，从概念来上来讲，每一个没有定义构造函数的类都会由编译器来合成一个默认构造函数，以使得可以定义一个该类的对象，但是默认构造函数是否真的会被合成，将视是否有需要而定。C++ standard 将合成的默认构造函数分为 trivial 和 notrivial 两种，前文所述的四种情况对应于notrivial默认构造函数，其它情况都属于trivial。对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p>
<h2 id="拷贝构造函数（copy-constuctor）"><a href="#拷贝构造函数（copy-constuctor）" class="headerlink" title="拷贝构造函数（copy constuctor）"></a>拷贝构造函数（copy constuctor）</h2><p>通常C++初级程序员会认为当一个类为没有定义拷贝构造函数的时候，编译器会为其合成一个，答案是否定的。<code>编译器只有在必要的时候在合成拷贝构造函数</code>。<br>那么编译器什么时候合成，什么时候不合成，合成的拷贝构造函数在不同情况下分别如何工作呢？这是本文的重点。</p>
<h3 id="拷贝构造函数的定义"><a href="#拷贝构造函数的定义" class="headerlink" title="拷贝构造函数的定义"></a>拷贝构造函数的定义</h3><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X::X( const X&amp; x);</div><div class="line">Y::Y( const Y&amp; y, int =0 );</div><div class="line">//可以是多参数形式，但其第二个即后继参数都有一个默认值拷贝构造函数的应用</div></pre></td></tr></table></figure>
<p>当一个类对象以另一个同类实体作为初值时，大部分情况下会调用拷贝构造函数。一般是这三种具体情况：</p>
<ul>
<li>显式地以一个类对象作为另一个类对象的初值，形如X xx=x;</li>
<li>当类对象被作为参数交给函数时。</li>
<li>当函数返回一个类对象时。<br>后两种情形会产生一个临时对象。</li>
</ul>
<h3 id="编译器何时合成拷贝构造函数"><a href="#编译器何时合成拷贝构造函数" class="headerlink" title="编译器何时合成拷贝构造函数"></a>编译器何时合成拷贝构造函数</h3><p>并不是所有未定义有拷贝构造函数的类编译器都会为其合成拷贝构造函数，编译器<code>只有在必要的时候才会为其合成拷贝构造函数</code>。所谓必要的时刻是指编译器在普通手段无法完成解决“当一个类对象以另一个同类实体作为初值”时，才会合成拷贝构造函数。也就是说，当常规武器能解决问题的时候，就没必要动用非常规武器。</p>
<p>如果一个类<code>没有定义拷贝构造函数</code>，通常按照<code>“成员逐一初始化(DefaultMemberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”</code>——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default MemberwiseInitialization)”的手法。</p>
<p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）[^注1]。也就是说在能使用这种常规方式来解决“一个类对象以另一个同类实体作为初值”的时候，编译器是不需要合成拷贝构造函数的。但有些时候常规武器不那么管用，我们就得祭出非常规武器了——拷贝构造函数。有以下几种情况之一，位逐次拷贝将不能胜任或者不适合来完成“一个类对象以另一个同类实体作为初值”的工作。此时，如果类没有定义拷贝构造函数，那么编译器将必须<code>为类合成一个拷贝构造函数</code>。</p>
<ul>
<li>当类内含一个成员对象，而后者的类声明有一个拷贝构造函数时（不论是设计者定义的还是编译器合成的）。</li>
<li>当类继承自一个声明有拷贝构造函数的类时（同样，不论这个拷贝构造函数是被显示声明还是由编译器合成的）。</li>
<li>类中声明有虚函数。</li>
<li>当类的派生串链中包含有一个或多个虚基类。</li>
</ul>
<p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p>
<p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p>
<p>对于继承串链中有虚基类的情况，问题同样出现在继承类向基类提供初值的情况，此时位逐次拷贝有可能破坏对象中虚基类子对象的位置。</p>
<h2 id="命名返回值优化和成员初始化队列"><a href="#命名返回值优化和成员初始化队列" class="headerlink" title="命名返回值优化和成员初始化队列"></a>命名返回值优化和成员初始化队列</h2><h3 id="命名返回值优化"><a href="#命名返回值优化" class="headerlink" title="命名返回值优化"></a>命名返回值优化</h3><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p>
<p>foo()的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">X foo() </div><div class="line">&#123; </div><div class="line">    X xx; </div><div class="line">    if(...) </div><div class="line">        return xx; </div><div class="line">    else </div><div class="line">        return xx; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化后的foo()以result取代xx：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void  foo(X &amp;result)</div><div class="line">&#123;</div><div class="line">    result.X::X();</div><div class="line">    if(...)</div><div class="line">    &#123;</div><div class="line">        //直接处理result</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        //直接处理result</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>
<p>注：Lippman在《深度探索C++》书中指出NRV的开启与关闭取决于是否有显式定义一个拷贝构造函数，我实在想不出有什么理由必须要有显示拷贝构造函数才能开启NRV优化，于是在vs2010中进行了测试，测试结果表明，在release版本中，不论是否定义了一个显式拷贝构造函数，NRV都会开启。由此可见vs2010并不以是否有一个显式拷贝构造函数来决定NRV优化的开启与否。但同时，立足于这一点，可以得出Lippman所说的以是否有一个显式定义的拷贝构造函数来决定是否<br>开启NRV优化，应该指的是他自己领导实现的cfront编译器，而非泛指所有编译器。那么cfront又为什么要以是否定义有显示的拷贝构造函数来决定是否开启NRV优化呢？我猜测，他大概这样以为，当显式定义有拷贝构造函数的时候一般代表着要进行深拷贝，也就是说此时的拷贝构造函数将费时较长，在这样的情况下NRV优化才会有明显的效果。反之，不开启NRV优化也不是什么大的效率损失。</p>
<p>另外，有一点要注意的是，NRV优化，有可能带来程序员并不想要的结果，最明显的一个就是——当你的类依赖于构造函数或拷贝构造函数，甚至析构函数的调用次数的时候，想想那会发生什么。由此可见、Lippman的cfront对NRV优化抱有更谨慎的态度，而MS显然是更大胆。</p>
<h3 id="成员初始化队列（Member-Initialization-List）"><a href="#成员初始化队列（Member-Initialization-List）" class="headerlink" title="成员初始化队列（Member Initialization List）"></a>成员初始化队列（Member Initialization List）</h3><p>对于初始化队列，我相信厘清一个概念是非常重要的：在构造函数中对于对象成员的初始化发生在初始化队列中——或者我们可以把初始化队列直接看做是对成员的定义，而构造函数体中进行的则是赋值操作。所以不难理解有四种情况<br>必须用到初始化列表：</p>
<ul>
<li>有const成员</li>
<li>有引用类型成员</li>
<li>成员对象没有默认构造函数</li>
<li>基类对象没有默认构造函数</li>
</ul>
<p>前两者因为要求定义时初始化，所以必须明确的在初始化队列中给它们提供初值。后两者因为不提供默认构造函数，所有必须显示的调用它们的带参构造函数来定义即初始化它们。</p>
<p>显而易见的是当类中含有对象成员或者继承自基类的时候，在初始化队列中初始化成员对象和基类子对象会在效率上得到提升——省去了一些赋值操作嘛。</p>
<p>最后，一个关于初始化队列众所周知的陷阱，初始化队列的顺序，请参考《C++primer》或者《深度探索C++对象模型》。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/02/关于对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/02/关于对象/" itemprop="url">关于对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-02T21:54:08+08:00">
                2015-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-的额外成本"><a href="#C-的额外成本" class="headerlink" title="C++的额外成本"></a>C++的额外成本</h2><p>C++较之C的最大区别，无疑在于面向对象。类相较于C的struct不仅只包含了数据，同时还<br>包括了对于数据的操作。在语言层面上C++带来了很多面向对象的新特性，类、继承、多态<br>等等。新特性使得C++更加强大，但同时却伴随着空间布局和存取时间的额外成本。作为一<br>个以效率为目标的语言，C++对于面向对象的实现，其实不大，这些额外成本主要由<br>virtual引起，包括：</p>
<p>virtual function 机制，用来支持“执行期绑定”。<br>virtual base class ——虚基类机制，以实现共享虚基类的 subobject。<br>除此之外C++没有太多理由比C迟缓。</p>
<h2 id="三种对象模型"><a href="#三种对象模型" class="headerlink" title="三种对象模型"></a>三种对象模型</h2><p>C++类包含两种数据成员：静态数据成员和非静态数据成员；同时包含成员函数，静态函数和虚函数三种成员函数，这些机制在C++对象是如何被表现的？下面有三种模型可以用以表现它们——简单对象模型、表格驱动对象模型以及C++对象模型。也许你没兴趣去了解有几种方式可以实C++的对象模型，只想了解C++对象模型。然则，<code>C++对象模型是在前两种对象模型上发展而来的，甚至于局部上直接用到前两种对象模型</code>。</p>
<p>假定有一个Point类，我们将用三种对象模型来表现它。Point类如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Point  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">    Point( float xval ); </div><div class="line">    virtual ~Point();      </div><div class="line">    float x() const;  </div><div class="line">    static int PointCount();  </div><div class="line">protected:  </div><div class="line">    virtual ostream&amp;  print( ostream &amp;os ) const;</div><div class="line">    float _x;  </div><div class="line">    static int _point_count;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h3><p>简单对象模型：一个C++对象<code>存储了所有指向成员的指针</code>，而成员本身<code>不存储</code>在对象中。也就是说不论数据成员还是成员函数，也不论这个是普通成员函数还是虚函数，它们都存储在对象本身之外，同时对象保存指向它们的指针。</p>
<p><img src="/images/cpp/cpp_1.png" alt="image"></p>
<p>简单对象模型对于编译器来说虽然极尽简单,但同时付出的代价是空间和执行期的效率.显而易见的是对于每一个成员都要额外搭上一个指针大小的空间以及对于每成员的操作都增加了一个间接层。因此<code>C++并没有采用这样一种对象模型</code>，但是被用到了C++中“指向成员的指针”的概念当中。</p>
<h3 id="表格驱动对象模型"><a href="#表格驱动对象模型" class="headerlink" title="表格驱动对象模型"></a>表格驱动对象模型</h3><p><img src="/images/cpp/cpp_2.png" alt="image"></p>
<p>表格驱动模型则更绝，它将对象中所有的成员都抽离出来<code>在外建表</code>，而对象本身只存储指向这个表的指针。右图可以看到，它将所有的数据成员抽离出来建成数据成员表，将所有的函数抽取出来建成一张函数成员表，而对象本身只保持一个指向<code>数据成员表</code>的指针。</p>
<p>侯大大认为，在对象与成员函数表中间应当加一个虚箭头，他认为这是Lippman的疏漏之处，应当在对象中保存指向函数成员表的指针。</p>
<p>然而我在这儿还是保留原书（而非译本）的截图，因为以我之拙见，不保存指向成员函数表的指针也没有妨碍。因为形如float Point::x()的成员函数实际上相当于float x(Point*)类型的普通函数，因此保存指向成员函数表的指针当属多此一举。</p>
<p>当然<code>C++也没有采用这一种对象模型</code>，但C++却以此模型作为支持虚函数的方案。</p>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><p>所有的<code>非静态数据</code>成员存储在<code>对象本身</code>中。所有的<code>静态数据成员</code>、<code>成员函数（包括静态与非静态）</code>都置于<code>对象之外</code>。另外，用一张<code>虚函数表（virtual table)</code>存储所有指向虚函数的指针，并在表头附加上一个该类的type_info对象，在对象中则保存一个指向虚函数表的指针。如下图：</p>
<p><img src="/images/cpp/cpp_3.png" alt="image"></p>
<h2 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h2><p>按照lippman的意思是，struct仅仅是给想学习C++的C程序员攀上高峰少一点折磨。但遗憾的是当我开始学C++的时候这个问题给我带来更多的疑惑。以我的认识class与struct仅限一个默认的权限（后者为public前者为private）的不同。有时我甚至觉得只有一点畸形，他们不应当如此的相像，我甚至认为struct不应该被扩充，仅仅保存它在C中的原意就好了。[实际上struct还要复杂一点,它有时表现的会和C struct完全一样，有时则会成为class的胞兄弟。]</p>
<p>一个有意思的C技巧（但别在C++中使用）</p>
<p>在C中将一个一个元素的数组放在struct的末尾，可以令每个struct的对象拥有可变数组。<br>看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct mumble &#123;  </div><div class="line">    /* stuff */  </div><div class="line">    char pc[ 1 ];  </div><div class="line">&#125;;  </div><div class="line">// grab a string from file or standard input  </div><div class="line">// allocate memory both for struct &amp; string  </div><div class="line">struct mumble *pmumb1 = ( struct mumble* )  </div><div class="line">    malloc(sizeof(struct mumble)+strlen(string)+1);  </div><div class="line">strcpy( &amp;mumble.pc, string );</div></pre></td></tr></table></figure></p>
<p>这是一个很有意思的小技巧，但是别在C++中使用。因为C++的内存布局相对复杂。例如被继<br>承，有虚函数… 问题将不可避免的发生。</p>
<h2 id="三种编程典范"><a href="#三种编程典范" class="headerlink" title="三种编程典范"></a>三种编程典范</h2><p>程序模型<br>ADT模型<br>面向对象模型<br>纯粹使用一种典范编程，有莫大的好处，如果混杂多种典范编程有可能带来意想不到的后果，例如将继承类的对象赋值给基类对象，而妄想实现多态，便是一种ADT模型和面向对象模型混合编程带来严重后果的例子。</p>
<h2 id="一个类的对象的内存大小包括："><a href="#一个类的对象的内存大小包括：" class="headerlink" title="一个类的对象的内存大小包括："></a>一个类的对象的内存大小包括：</h2><ul>
<li>所有非静态数据成员的大小。</li>
<li>由内存对齐而填补的内存大小。</li>
<li>为了支持virtual有内部产生的额外负担。<br>如下类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class ZooAnimal &#123;  </div><div class="line">public:  </div><div class="line">    ZooAnimal();  </div><div class="line">    virtual ~ZooAnimal();  </div><div class="line">    virtual void rotate();  </div><div class="line">protected:  </div><div class="line">    int loc;  </div><div class="line">    String name;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在32位计算机上所占内存为16字节：int四字节，String8字节（一个表示长度的整形，一个指向字符串的指针），以及一个指向虚函数表的指针vptr。对于继承类则为基类的内存大小加上本身数据成员的大小。在cfront中其内存布局如下图：</p>
<p><img src="/images/cpp/cpp_3.png" alt="对象的内存布局"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/15/TinyXPath-对于xpath标准的支持/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/15/TinyXPath-对于xpath标准的支持/" itemprop="url">TinyXPath 对于xpath标准的支持</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-15T23:52:33+08:00">
                2015-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>xpath是一种基于xml的查询标准，一般的xml解析工具都具有，有的因为卓越的xpath性能而出名，其匹配查询算法牛逼而又高效，和正则有的一拼。虽然我现在大部分从事前端工作了，但是对于原理性的东西还是很喜欢研究，jQuery以前也支持基本的XPath表达式的css选择，不过好像性能没有css选择器强大，被放弃了。</p>
<p>这里介绍下本人试验TinyXpath 1.3.0 对于Xpath 1.0 的支持情况</p>
<p>tinyxpath： <a href="http://tinyxpath.sourceforge.net/" target="_blank" rel="external">http://tinyxpath.sourceforge.net/</a></p>
<p><img src="/images/cpp/xpath_1.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/13/scxml-图像展示器-（基于C-MFC-GDI-tinyxpath的实现）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/13/scxml-图像展示器-（基于C-MFC-GDI-tinyxpath的实现）/" itemprop="url">scxml 图像展示器 （基于C++ MFC GDI tinyxpath的实现）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-13T22:50:12+08:00">
                2015-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人项目/" itemprop="url" rel="index">
                    <span itemprop="name">个人项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Scxml是w3c出来的基于状态机的对话脚本语言标准，具体内容可以谷歌到，这里讲述自己开发的一个把scxml转化为可交互图形的程序。</p>
<p>源代码上传到了<a href="https://github.com/su6838354/scxml_exec" target="_blank" rel="external">github</a></p>
<h3 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h3><p>基本原则是把具有状态机关系的xml语言转换为矩形、矩形之间的线、矩形的子父级关系。</p>
<p>整个模块由下而上分为 5部分</p>
<ul>
<li>1.Scxml 脚本</li>
<li>2.Parser 层（依赖Tinyxpath）</li>
<li>3.Model 层</li>
<li>4.Layout 层 (Model转化为虚拟图形对象)</li>
<li>5.View 图形（MFC和GDI [ Gdiplus::Graphics]实现 ）</li>
</ul>
<p>Parser层会通过tinyxpth解析scxml脚本并产出Modal对象，并对上层提供getState，getTransitions，GetFinals等接口，接口之间的参数类型就是Model层定义的；</p>
<p>Layout层获取所有的state和transition，然后转化为虚拟图形对象ScxmlRectangle和ScxmlLine等；</p>
<p>View层通过MFC实现，将虚拟图形对象进行描绘和渲染</p>
<h3 id="包设计"><a href="#包设计" class="headerlink" title="包设计"></a>包设计</h3><p>下面这个是包设计图，UI从LayOut中获得图形信息画图，LayOut从IGetScxmlObject获得解析信息，<br><img src="/images/cpp/scxml_1.png" alt=""><br>Parser层通过Iread可以读取到scxml文件中的元素，ModelFactory将获取的元素转换为自定义对象，提供IGetModel给layout</p>
<h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>下面是layout层和parser层的用例图，</p>
<ul>
<li>layout用于描述自动状态机布局的过程，包含从scxml_parser模块获取对象，根据对象内容计算出整个图形布局<ul>
<li>Rectangle Scxml   用于输出图形的中心点、宽度、高度，线条起始点等内容</li>
<li>GetScxmlObject   解析scxml对象，生成矩形和有向线段</li>
</ul>
</li>
<li><p>Parser描述从scxml格式解析成对象的过程，以及和外部模块之间的关系，</p>
<ul>
<li>Read scxml     主要用于按照需求读取scxml文件内容，其调用tinyxpath模块执行自定义的xpath语法</li>
<li><p>create model          将读取的内容构建成对象</p>
<p><img src="/images/cpp/scxml_2.png" alt=""> </p>
</li>
</ul>
</li>
</ul>
<h3 id="Layout的类图如下"><a href="#Layout的类图如下" class="headerlink" title="Layout的类图如下"></a>Layout的类图如下</h3><ul>
<li>Line        线，包含起始点和终点</li>
<li>Rectangle       矩形，包含中心点、宽度、高度</li>
<li><p>ScxmlLayout         包含所有矩形和线条的数据，拥有计算整个图形布局的方法</p>
<p><img src="/images/cpp/scxml_3.png" alt=""> </p>
<h3 id="Layout时序图"><a href="#Layout时序图" class="headerlink" title="Layout时序图"></a>Layout时序图</h3></li>
<li><p>根据scxml对象，执行LayOut算法，生成图形信息</p>
</li>
<li><p>调用scxml_parser模块，获取自定义的scxml对象，生成相应的图形内容，执行布局算法，输出图形信息</p>
<p> <img src="/images/cpp/scxml_4.png" alt=""> </p>
</li>
</ul>
<h3 id="Parser-类图如下"><a href="#Parser-类图如下" class="headerlink" title="Parser 类图如下"></a>Parser 类图如下</h3><ul>
<li>Xtinyxpath     调用Xpath语言查找scxml元素</li>
<li><p>ScxmlParser          调用tinyxpath获取元素，封装为scxmlobject对象</p>
<p>   <img src="/images/cpp/scxml_5.png" alt=""></p>
</li>
</ul>
<h3 id="Parser时序图："><a href="#Parser时序图：" class="headerlink" title="Parser时序图："></a>Parser时序图：</h3><p>scxml文件解析过程     调用tinyxpath模块，实现在C++中内嵌使用xpath语言，按要求获取scxml元素，转化成自定义的对象，用于layout画图</p>
<p>  <img src="/images/cpp/scxml_6.png" alt=""></p>
<h3 id="展示效果如下"><a href="#展示效果如下" class="headerlink" title="展示效果如下"></a>展示效果如下</h3><p>下面为一个相对复杂的scxml，包含了并行、多层的嵌套关系</p>
<p>  <img src="/images/cpp/scxml_7.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg"
               alt="suyuan" />
          <p class="site-author-name" itemprop="name">suyuan</p>
           
              <p class="site-description motion-element" itemprop="description">东京下雨，淋湿巴黎</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suyuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
