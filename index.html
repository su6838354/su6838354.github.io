<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="东京下雨，淋湿巴黎">
<meta property="og:type" content="website">
<meta property="og:title" content="苏远的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="苏远的博客">
<meta property="og:description" content="东京下雨，淋湿巴黎">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏远的博客">
<meta name="twitter:description" content="东京下雨，淋湿巴黎">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>苏远的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e56d57ba89bb058da8fdd8841e98770f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏远的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/19/huwai-1511105901710/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/19/huwai-1511105901710/" itemprop="url">户外项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T23:38:21+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人项目/" itemprop="url" rel="index">
                    <span itemprop="name">个人项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一套面向户外俱乐部和户外爱好者的 活动展示，报名，分享游记的管理工具</p>
<ul>
<li><p>预览<br><a href="http://hw.suleyan.com/user-hw" target="_blank" rel="external">手机用户页面</a> 建议手机查看<br><a href="http://hw.suleyan.com/" target="_blank" rel="external">pc管理后台</a> 账户: admin 123456</p>
<p>  香港服务器，带宽又有限，访问可能有点慢</p>
</li>
<li><p>代码地址<br><a href="git@github.com:sfm-rc/koa2-hw.git">后端 nodejs</a><br><a href="git@github.com:sfm-rc/hw-admin.git">管理后台前端 react</a><br><a href="git@github.com:sfm-rc/hw.git">用户侧前端 react</a></p>
</li>
</ul>
<h1 id="主要技术栈"><a href="#主要技术栈" class="headerlink" title="主要技术栈"></a>主要技术栈</h1><p>webpack<br>react<br>redux<br>koa2<br>antd<br>antd-mobile<br>atool<br>dora<br>pm2<br>mysql<br>docker</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>可以把整套服务起在docker中，下面没有涉及mysql，可以通过–link mysql_server单独到一个mysql docker容器；<br>在docker中取下三份代码；</p>
<ul>
<li><p>koa2 唯一需要起到服务代码<br>提供服务接口和手机页面静态资源服务</p>
<pre><code>npm install &amp;&amp; npm run compile    
pm2 start pm2.json
</code></pre></li>
<li><p>hw 中<br>提供手机页面静态资源</p>
<pre><code>npm install &amp;&amp; npm run build:prod    
cp dist ../koa2-hw/public
</code></pre></li>
<li><p>hw-admin<br>提供pc管理后台静态资源</p>
<pre><code>npm install &amp;&amp; npm run build
</code></pre></li>
<li><p>nginx<br>提供手机页面和管理后台入口</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">nginx 中配置</div><div class="line">upstream hwserver &#123;</div><div class="line"> server 127.0.0.1:3001;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line">    #access_log  /var/log/nginx/host.access.log  main;</div><div class="line"></div><div class="line">#    location / &#123;</div><div class="line">#        root   /usr/share/nginx/html;</div><div class="line">#        index  index.html index.htm;</div><div class="line">#    &#125;</div><div class="line"></div><div class="line"></div><div class="line">        root /usr/webapp/hw-admin/dist;</div><div class="line"></div><div class="line">        location /user-hw &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /user-hw-static &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /hw &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /admin-hw &#123;</div><div class="line">                root /user/webapp/hw-admin/dist;</div><div class="line">                rewrite &apos;^/admin-hw/(.*)&apos; /$1;</div><div class="line">#               try_files $uri /index.html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">                #proxy_pass http://hwserver;</div><div class="line">                #rewrite ^(.*)$ index.html</div><div class="line">        #       root /user/webapp/hw-admin/dist;</div><div class="line">                try_files $uri /index.html;</div><div class="line">        &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/基于create-react-app-快速搭建react项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/基于create-react-app-快速搭建react项目/" itemprop="url">基于create-react-app快速搭建react项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T18:28:31+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>本身安装了nodejs，npm或者yarn</p>
<pre><code>yarn global add create-react-app
</code></pre><p>或者</p>
<pre><code>npm install -g create-react-app
</code></pre><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><pre><code>create-react-app react-demo
</code></pre><p><img src="/images/1504432144489.png" alt="image"></p>
<p><img src="/images/1504432202611.png" alt="image"></p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>查看scripts 中可以执行等命令</p>
<pre><code>npm run-script
</code></pre><p><img src="/images/1504432536022.png" alt="image"></p>
<p>我们可以猜想npm start 是开发模式下，启动服务热加载编译；npm run build 自然是编译程序</p>
<p>执行</p>
<pre><code>npm start 
</code></pre><p>会发现自动打开了浏览器<a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 属于你等react web 已经出现了<br>可以打开App.js编写代码；<br>另外该开发套件本身没有包含react-router，你需要自己引入</p>
<pre><code>yarn add react-router
yarn add react-router-dom
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><a href="https://github.com/su6838354/react-demo" target="_blank" rel="external">https://github.com/su6838354/react-demo</a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这时候整个react项目已经搭建好了，不需要知道任何的webpack等工程化技术，在node_modules/react-scripts 目录下我们可以发现该开发套件的真谛。<br><img src="/images/1504432860140.png" alt="image"></p>
<blockquote>
<p>bin     执行react-scripts 命令的入口<br>config 根据环境变量和设置，webpack/环境/jest/polyfill等一些配置<br>scripts 各种脚本，编译,测试，初始化，开发等，为package.json中定义的scripts和最初创建项目的命令服务<br>temple 最初创建项目等时候 采用这套模版生成我们最初的项目</p>
</blockquote>
<p>在未来项目配置不符合你等需求等时候，可以查看 <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md</a><br>修改配置以满足需求；</p>
<p>比如 需要修改引入等js，css等相对路径，修改下自己等环境变量即可<br>export PUBLIC_URL=’/home/static/‘，当然还有其他方式比如修改package.json的homepage<br>参考<br><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-assets-outside-of-the-module-system" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-assets-outside-of-the-module-system</a></p>
<p><img src="/images/1504434422598.png" alt="image"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/XSS和CSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/XSS和CSRF/" itemprop="url">XSS 和CSRF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T20:30:39+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="XSS：跨站脚本（Cross-site-scripting）"><a href="#XSS：跨站脚本（Cross-site-scripting）" class="headerlink" title="XSS：跨站脚本（Cross-site scripting）"></a>XSS：跨站脚本（Cross-site scripting）</h1><ul>
<li><p>示例<br>比如 别人在论坛中提交了一段代码<br><code>while(true){
  alert(&#39;1&#39;)
}</code><br>当自己打开这个论坛的时候，就会一直执行这段js，这段js可以用来盗号或者执行未授权的操作</p>
</li>
<li><p>原理<br>XSS 其实就是所谓的 HTML 注入，攻击者的输入没有经过后台的过滤直接进入到数据库，最终显示给来访的用户。如果攻击者输入一段 js 脚本，就能窃取来访者的敏感信息（比如 Cookie），实现伪装成来访者对网站发送危险请求。</p>
</li>
<li><p>防御<br>避免 XSS 的方法之一主要是对用户输入的内容进行过滤，比如 PHP 里面的 htmlspecialchars() 函数。</p>
</li>
</ul>
<h1 id="CSRF（Cross-site-request-forgery）跨站请求伪造，又叫XSRF"><a href="#CSRF（Cross-site-request-forgery）跨站请求伪造，又叫XSRF" class="headerlink" title="CSRF（Cross-site request forgery）跨站请求伪造，又叫XSRF"></a>CSRF（Cross-site request forgery）跨站请求伪造，又叫XSRF</h1><blockquote>
<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>
</blockquote>
<ul>
<li><p>原理:<br>要完成一次CSRF攻击，受害者必须依次完成以下步骤：</p>
<ul>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。危险网站B，它里面有一段HTML的代码如下：　　<br><code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></li>
<li>你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块！</li>
</ul>
</li>
<li><p>防御<br>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！<br>通过下面途径可以防御：</p>
<ul>
<li>敏感动作使用post，不要用get，post 受到跨域限制，浏览器在发送post请求前，发送option 询问服务端是否允许该源（域名+端口）的访问，假如自己站点存在让黑客发送危险请求的 漏洞，该方法就没用了。</li>
<li>给每个表单加入随机 Token 进行验证，这样B页面无法获取A页面的 Token 导致请求验证失败，从而防止了 CSRF。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/浪潮之巅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/浪潮之巅/" itemprop="url">浪潮之巅</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T22:07:05+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index">
                    <span itemprop="name">阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AT&amp;T、IBM、微软、苹果、google等IT公司的发展历史，揭示科技工业的胜败规律，说明这些公司是如何在每一次科技革命浪潮到来时站在浪尖，实现跨越式发展的。</p>
<p>（2017-11-25日更新）</p>
<h3 id="阿里和腾讯"><a href="#阿里和腾讯" class="headerlink" title="阿里和腾讯"></a>阿里和腾讯</h3><p>阿里、腾讯、百度的崛起，头条、美团、滴滴的紧随其上，为国内的互联网氛围增加了更浓烈的火药味，谁会持续站在浪潮之巅。</p>
<p>都说科技改变生活，腾讯和阿里在生活中无处不在，但是最新的赛季到底谁是最强王者，是腾讯爸爸，还是阿里爸爸？还是说最后会半路杀出个程咬金？<br><img src="/images/book/b_5.jpg" alt=""><br><img src="/images/book/b_6.jpg" alt=""><br><img src="/images/book/b_7.jpg" alt=""><br><img src="/images/book/b_8.jpg" alt=""></p>
<h3 id="我消灭你，与你无关-打败你的不一定是对手而是一个过路人"><a href="#我消灭你，与你无关-打败你的不一定是对手而是一个过路人" class="headerlink" title="我消灭你，与你无关 打败你的不一定是对手而是一个过路人"></a>我消灭你，与你无关 打败你的不一定是对手而是一个过路人</h3><p>这是一个摧毁你，却与你无关的时代；这是一个跨界打劫你，你却无力反击的时代；这是一个你醒来太慢，干脆就不用醒来的时代；这是一个不是对手比你强，而是你根本连对手是谁都不知道的时代！</p>
<p>最近，尼康退出中国，裁员两千人！</p>
<p><img src="/images/book/b_1.jpeg" alt=""></p>
<p>很多人以为尼康是被同行打败，没想到居然是毫无相关的行业。尼康直接宣布破产的真相：受智能手机普及的影响！<br>中国有一部很牛的科幻小说，名字叫做《三体》。里面有句话，叫做：“我消灭你，与你无关。”<br>这句话真够嚣张跋扈，但却充满大智慧，说明了大趋势，揭示了整个人类世界前进和发展的基本规律。<br>比如，今年康师傅和统一方便面的销量急剧下滑，不过它们的对手真不是白象、今麦郎，而是美团、饿了么等外卖。<br>比如，打败口香糖不是益达，而是微信、王者荣耀。在超市收银台这个消费场景，过去顾客在排队缴费的时候无聊就往购物篮里拿上两盒口香糖，而今天大家都在看微信、刷朋友圈、玩王者。<br>比如，共享单车，一块钱，随便骑，骑到任何地方，停下，锁车就走，不用管。这个东西一出来，黑车司机哭了。卖单车的店铺、修自行车的小摊子，生意都一落千丈，关门是迟早的事情。<br>怎么样，大趋势是很残酷的，它杀人是不眨眼，也不会流血的，根本不见红。<br>说声对不起？不好意思，不关我的事，我根本没关注到你，只是一个不小心，让你倒霉了。这就叫：我消灭你，但与你无关。</p>
<p>结语：<br>在这个跨界打劫、飞速变化的时代，你永远也无法想象下个竞争对手，你也很难猜到新兴的什么行业就打败了传统的什么行业。<br>我们唯一能做的，就是保持一个足够开阔的视野，每当有新鲜事物发生、新兴行业的兴起的时候，多去发散思考一下，说不定想到的某些点，就串联成线，就可以比别人早一点看到未来，早一点抓住机遇呢。<br>你不自我革新，不自我变革，就只能等着别人来革你的命！<br>既然“羊毛出在狗身上，由猪买单”，同样““我消灭你，与你无关。”！这是今天的状况！</p>
<h3 id="AT-amp-T拥有垄断资源的百年公司，为何最后走向衰落？"><a href="#AT-amp-T拥有垄断资源的百年公司，为何最后走向衰落？" class="headerlink" title="AT&amp;T拥有垄断资源的百年公司，为何最后走向衰落？"></a>AT&amp;T拥有垄断资源的百年公司，为何最后走向衰落？</h3><ul>
<li><p>前身是贝尔电话公司。屡次遭反垄断法的切割和约束，却没有倒下，反而因此修枝剪叶，发展得更好。</p>
<blockquote>
<p>反垄断法逼着公司进行科技进步，而不能利用垄断优势坐享其成。后者往往令公司失去技术领先地位。</p>
</blockquote>
</li>
<li><p>终结AT&amp;T的内因是贪婪和短视，为了股东利益最大化，在无线通讯和互联网技术革命来临的关键时刻，将公司业务分拆成小公司上市，卖股票挣钱，杀鸡取卵，最终被下一波浪潮吞没，错失发展机会。</p>
<blockquote>
<p>当一家公司没有人对它有控制权时，它的长期发展就会有问题。<br>1995年，美国股票开始疯涨，AT&amp;T的股票大部分被华尔街投资银行掌控，这些人只为了自己的股票利益，完全不顾公司的长期发展，因而令公司屡屡做出短视的错误决策。</p>
</blockquote>
</li>
</ul>
<p>在阿里、京东之前，王峻涛和8848才是中国电商对鼻祖，但是失去控制权，又错过了最佳上市时机，导致8848退出了历史对舞台，也让后来对阿里巴巴没有对手。<br><img src="/images/book/b_2.jpeg" alt=""></p>
<h3 id="蓝色巨人IBM——基因决定了IBM不会成为PC大王"><a href="#蓝色巨人IBM——基因决定了IBM不会成为PC大王" class="headerlink" title="蓝色巨人IBM——基因决定了IBM不会成为PC大王"></a>蓝色巨人IBM——基因决定了IBM不会成为PC大王</h3><p><img src="/images/book/b_3.jpeg" alt=""><br>从机械时代的制表机起家，二战时还参加制造勃朗宁自动步枪和M1冲锋枪。</p>
<ul>
<li>第一次转型：从机械制造到计算机制造：领导电子技术革命潮流（1950S-1970S）<br>第二次世界大战是机械时代和电子时代的分水岭，1952年小沃森出任IBMCEO，领导电子技术革命的浪潮。其最大贡献是将计算机从高政府部门和军方推广到民间，将它的功能由科学计算变成商用。</li>
<li>错过全球信息化的大潮（1980S）<br>1976年，乔布斯发明第一台可商业化的个人电脑Apple-Ⅰ。随后IBM决定也要加快研制自己的PC，最终推出IBM-PC（1981），占领了大部分的微机市场。但是IBM最后并没有成为PC大王，而是推出了PC市场，原因有三：IBM的固有基因、反垄断后遗症、微软的出现。<ul>
<li>IBM的基因：锁定政府部门和企业单位为其主要客户，不屑于大众销售（效益太低）</li>
<li>1970-1980年IBM与司法部打了10年反垄断官司，最终和解结果是IBM必须公开一些技术，允许其他厂商制造兼容机，于是IBM就失去了优势，成为众多PC制造商之一。</li>
</ul>
</li>
<li>比尔盖茨凭操作系统摆了IBM一道：盖茨先空手套白狼，买了别人的DOS然后转卖IBM，他没有让IBM买断而是每台PC收不多的版权费，结果反而积少成多。他又利用合同漏洞再卖给别人，IBM却告不赢他。PC谁都可以做，操作系统用惯了却不能换，微软凭Windows系统确定了自己的垄断地位。<br>就这样，IBM成了80年代信息革命中的落伍者IBM出现了严重亏损，开始大幅裁员。</li>
<li>第二次转型：从计算制造到服务（1990S）<br>1993年，郭士纳出任IBMCEO，顺利把IBM从一个计算机硬件制造商公司转变为一个以服务和软件为核心的服务性公司。开始大力推广廉价开源的linux服务器。</li>
<li>IBM走了与AT&amp;T截然不同的路，AT&amp;T将一个好好的公司拆散卖掉，IBM将分出去的公司整合回来，打造了一个从硬件到软件到服务一条龙的航空母舰。现在，其开源服务器Linux仍然牢牢控制美国政府部门、军队、大公司和银行的业务。</li>
<li>IBM是一家保守的公司。他的创新能力很强，但很少花大力气去用新技术开拓新市场，因为政府、大企业更注重稳定性，不能接受一点错误。</li>
<li>2004年IBM将其PC业务（包括Thinkpad品牌）卖给联想，IBM去掉了亏损的部门，降低了成本，提高了盈利能力。联想也得到了Thinkpad这个第一品牌，提高了市场份额，也比大手大脚惯了的IBM更有能力降低笔记本部门的成本（人工便宜），因此这次买卖对联想IBM各有好处。</li>
</ul>
<h3 id="Apple——苹果公司和乔布斯神话"><a href="#Apple——苹果公司和乔布斯神话" class="headerlink" title="Apple——苹果公司和乔布斯神话"></a>Apple——苹果公司和乔布斯神话</h3><ul>
<li>1976 苹果计算机公司成立</li>
<li>1977乔布斯发明第一台可商业化的个人电脑Apple-Ⅰ</li>
<li>1984 推出采用图像视窗界面操作系统的麦金托什电脑（Macintosh）</li>
<li>1985 乔布斯和自己请来的CEO斯卡利（原百事可乐CEO）权力斗争，被踢出自己创办的公司</li>
<li>1986乔布斯收购了皮克斯（Pixar）动画工作室。推出玩具总动员，大受欢迎</li>
<li>1994 苹果告微软视窗系统抄袭它的麦金托什操作系统，官司最终和解。（其实大家都是抄施乐公司的）</li>
<li>1997 乔布斯重返苹果，任命为临时CEO。着手解决亏损的公司。</li>
<li>1998 推出iMac，苹果重新盈利</li>
<li>2001 推出ipod，颠覆了音乐产业</li>
<li>2007 推出iphone，颠覆了珍格格手机产业</li>
<li>2010 推出ipad，同年苹果公司的市值再次超过微软，成为全球最值钱的IT公司。</li>
<li>iphone 虽然打败了诺基亚，但是三星、华为、小米的崛起也让app感到了恐慌<br><img src="/images/book/b_4.jpg" alt=""></li>
</ul>
<h3 id="计算机工业生态三大规律"><a href="#计算机工业生态三大规律" class="headerlink" title="计算机工业生态三大规律"></a>计算机工业生态三大规律</h3><ul>
<li>摩尔定律（Moore’s law）：集成电路的集成度每两年会翻一番。<br>后来大家把周期缩短到18个月。现在，计算机等IT产品性能每18个月就翻一番。</li>
<li>安迪-比尔定律（Andy and Bill’s Law）<br>比尔（比尔盖茨）要拿走安迪（原英特尔CEO）所给的。即，每当以英特尔为首的硬件商提高了电脑性能，微软为首的软件商就会吃掉性能增加的大部分。反过来，只要微软不断推出更高级的操作系统，用户就不得不升级硬件更新，英特尔等硬件商就能生产更高级的芯片、硬盘挣钱。<br>该定律把原本属于耐用消费品的电脑手机变作消耗品，刺激整个IT行业的发展。<br>人们把微软和英特尔领导的PC时代称为WinTel体系。</li>
<li>反摩尔定律<br>一个IT公司如果今天和18个月钱卖掉同样多的、同样的产品，它的营业额就要降一半。<br>该定律刺激IT公司不断寻找技术突破，提高性能，同时也为新兴小公司提高超越大公司的机会。</li>
</ul>
<h3 id="英特尔"><a href="#英特尔" class="headerlink" title="英特尔"></a>英特尔</h3><p>微机时代的领导者只有两个，软件方面的微软和硬件方面的英特尔。</p>
<h3 id="微软——IT领域的罗马帝国"><a href="#微软——IT领域的罗马帝国" class="headerlink" title="微软——IT领域的罗马帝国"></a>微软——IT领域的罗马帝国</h3><ul>
<li>斗败苹果：以开放兼容占据市场<br>微软的崛起起源于乔布斯的一个致命错误：把未公开发布的麦金托什给盖茨看了，盖茨惊讶其图形化操作系统，回去一边拖延时间，一边自己暗暗研究新的操作系统windows。为了完成研发上的布局，盖茨要在市场上尽可能用它落后的DOS坚持到微软视窗系统开发出来，主要有两招做法：<ul>
<li>薄利多销：以每个拷贝5美分近乎免费的价格，把DOS预装在IBM-PC上，保证了大部分销售</li>
<li>来者不拒：同时吸引了大量个人在DOS上开发软件，使用户产生对微软的依赖；</li>
</ul>
</li>
<li>封闭的苹果主要败在微软人民战争的战术上：<br>技术领先的苹果走封闭式道路和纯技术路线，不开放麦金托什的技术，不允许其他厂商制造兼容机，坚持硬件软件一起卖；而IBM已经被迫开放兼容机，于是从上世纪80年代中期起，世界硬件市场的格局从苹果对IBM变成苹果对IBM加上所有兼容机。IBM-PC越做越便宜，市场占有率越来越高。微软则借IBM-PC的流行，以超低价为诱饵绑定操作系统在IBM-PC上，于是自己的市场占有率也不断攀升。另一方面又对第三方软件商以支持与合作的态度鼓励，于是微软的操作系统上积聚了大量廉价实用的软件。而苹果的最大败笔就是兼容性极差。连自己内部不同版本的机器都不兼容。</li>
<li>搞垮网景：靠垄断优势搞捆绑销售<br>上世纪90年代，互联网兴起，网景浏览器先拔头筹，大受欢迎。盖茨立即意识到要守住用户通向网络的大门，火速推出IE，用上杀手锏：与widows捆绑，免费提供给用户。网景就被斗垮了。微软这招百试不爽。当然也受反垄断控告，但微软以捆绑销售是为了防止盗版蒙混过关。</li>
</ul>
<h3 id="思科公司——乘着互联网浪潮起家的企业"><a href="#思科公司——乘着互联网浪潮起家的企业" class="headerlink" title="思科公司——乘着互联网浪潮起家的企业"></a>思科公司——乘着互联网浪潮起家的企业</h3><p>1985年，互联网刚刚冒头，为了把不同协议的局域网连在一起，急需能协调多协议的路由器，思科正好应运而生，1986年就推出多协议路由器，马上占领市场。</p>
<h3 id="雅虎——开创互联网免费模式"><a href="#雅虎——开创互联网免费模式" class="headerlink" title="雅虎——开创互联网免费模式"></a>雅虎——开创互联网免费模式</h3><ul>
<li>在1990s，互联网刚刚兴起，雅虎创始人杨致远和戴维•菲洛在斯坦福大学制作了给网页按主题分类的系统，方便搜索资料，后来越来越多人使用，最终创建公司（1995）。</li>
<li>雅虎对互联网最大的贡献是开创了互联网开放、免费的商业模式——浏览网页、使用搜索、邮箱等服务不收费，网站只把内容做好，致力提高流量，凭此赚取广告费实现盈利。</li>
<li>但是，雅虎的基因骨子里是个媒体公司，不是技术公司，后来他自不量力要与google斗技术，耗费大量资源，最终沦落到现在等待被收购的处境。假如他趁早放弃自己亏损的搜索业务，与google合作，专心做好自己的媒体，应该还能在互联网占有一席之地。</li>
</ul>
<h3 id="惠普——硅谷的见证人"><a href="#惠普——硅谷的见证人" class="headerlink" title="惠普——硅谷的见证人"></a>惠普——硅谷的见证人</h3><ul>
<li>斯坦福工业园最早的入驻者之一，生产电子仪器起家，后来进入计算机市场，发明喷墨打印机。</li>
<li>但由于女CEO菲奥莉娜坚持收购亏损的康柏公司（电脑硬件生产），企图联合其市场占有率挑战戴尔，结果两个问题重重的公司合并后业绩更差。惠普一落千丈。</li>
<li>2005年，赫德接管，开源节流，开创惠普的快速发展期。但后因性骚扰事件离职。</li>
<li>惠普从来没有领导过哪次技术浪潮，业务也越来越向不稳定低利润的消费电子公司而不是创新公司靠拢，因此前景并不很美妙。</li>
</ul>
<h3 id="摩托罗拉——没落的贵族"><a href="#摩托罗拉——没落的贵族" class="headerlink" title="摩托罗拉——没落的贵族"></a>摩托罗拉——没落的贵族</h3><ul>
<li>曾经的无线通信领域的领先者，手机通信的发明者，发明大哥大（模拟手机），技术和品质一直领先。</li>
<li>摩托罗拉在二战后到1990S在模拟手机、计算机处理器、数字处理芯片（DSP）领域上都是大哥大地位，但进入数字移动通信时代后却败给了诺基亚一众非老牌通信厂家；计算机处理器败给了英特尔、DSP败给了德州仪器。</li>
<li>作者认为是摩托罗拉自己的基因决定了这一切。其公司的传统信念过于重视技术，对外观、功能的关注较少，低估了消费者对这方面的重视度。产品的开发周期又太长，最终落伍了。</li>
<li>2000年前后的铱星计划的失败给了摩托罗拉沉重的打击，这个计划的技术无与伦比却超前于市场。</li>
<li>摩托罗拉三个领域同时发展，战线太长，如果专注一个，或许还能在某一领域保持老大地位。</li>
<li>进入智能机时代后，摩托罗拉铁了心把赌注全押在Android上，市场反响不错。</li>
</ul>
<h3 id="一个IT公司创业成功必须具备的条件"><a href="#一个IT公司创业成功必须具备的条件" class="headerlink" title="一个IT公司创业成功必须具备的条件"></a>一个IT公司创业成功必须具备的条件</h3><ul>
<li>比起谋臣，一个有领袖气质的创始人更可能成功</li>
<li>光有好团队和技术不够，还要有商业头脑，还必须找到一个能盈利的商业模型（business model）</li>
<li>要有卓越的判断力和执行力，才能在大风大浪的硅谷生存下去</li>
<li>一个新公司的成功很大程度要看外部环境好不好。</li>
<li>最重要的是，创业者要有好运气。</li>
</ul>
<h3 id="信息产业的规律性："><a href="#信息产业的规律性：" class="headerlink" title="信息产业的规律性："></a>信息产业的规律性：</h3><ul>
<li>70-20-10律：在信息产业的同一领域里，一般容不下三个以上的主要竞争者，老大、老二和老三的市场占有率比例大概是70%比20%，剩下10%由一大群小产家分。</li>
<li>诺威格定律：一家公司的市场占有率超过50%后，就无法再使市场占有率翻番了。所以它必须不断寻找新的成长点，或扩展业务，或彻底转型进入其他行业，但由于企业基因决定定律，转型成功很难。</li>
<li>企业基因决定定律：一个公司创始初期形成的企业文化和商业模式、风格将深刻影响企业的发展。比如苹果至今仍然保持着硬件软件一起卖的相对封闭的商业模式。</li>
</ul>
<h3 id="风险投资和华尔街对科技产业的贡献"><a href="#风险投资和华尔街对科技产业的贡献" class="headerlink" title="风险投资和华尔街对科技产业的贡献"></a>风险投资和华尔街对科技产业的贡献</h3><p>风险投资、天使投资人是科技创业者最坚实的后盾，是幕后的英雄；投资银行和华尔街则是吹鼓手，有利可图时可以捧你，无利可图则可以摔死你。</p>
<h3 id="挑战者Google——技术和商业的完美结合"><a href="#挑战者Google——技术和商业的完美结合" class="headerlink" title="挑战者Google——技术和商业的完美结合"></a>挑战者Google——技术和商业的完美结合</h3><ul>
<li>找到自己企业正确的使命非常重要，这决定着该企业是否可以为大众市场所接受。比如微软的盖茨明确自己的使命是让计算机便宜下来，并且变得好用。他做到了，于是成为微机之王。Google的创始人布林和佩奇很早则明白，在互联网时代，让所有人很容易免费上网并方便地找到自己想要的东西的公司，必将成为互联网之王。（关键词：免费和方便）他们做到了，于是成为了互联网之王。</li>
<li>他们都是面向大众市场，专注于每个人都要使用的服务，于是挣到了最大份额的钱。而面向企业用户的IBM和面向精英的苹果，由于市场的变化和不确定性比较大，企业的抗风险能力自然比不上靠大众市场吃饭的Google和微软，因为不论经济形势好坏大家都要买日用品，都要用PC，都要上网。</li>
<li>Google的Android发展模式是学微软的做法，横着吃整个市场，他只关心最重要的操作系统部分，而把上下游全部交出去。比微软更绝的是，Android是免费的。</li>
</ul>
<h3 id="诺基亚——成功的转基因公司"><a href="#诺基亚——成功的转基因公司" class="headerlink" title="诺基亚——成功的转基因公司"></a>诺基亚——成功的转基因公司</h3><p>诺基亚最初只是芬兰一家木工公司，最后竟成功转型成为世界上最大的手机制造商，原因有三：</p>
<ul>
<li>抓住了移动通信从模拟到数字化的契机<br>80年代，手机通信从第一代模拟时代向数字化时代转变。欧洲抢先制定了新一代移动通信标准GSM，第一个投入商业运行的GSM移动通信电话网络就是芬兰公司运营的，手机的提供商就是诺基亚公司。<br>而美国此时同时出现了多个标准，非常混乱，最终GSM胜出一统天下，美国摩托罗拉也就失去先机。</li>
<li>政府的大力扶植</li>
<li>推翻了在模拟时代摩托罗拉制定的商业竞争规则。<br>摩托罗拉败在没有发现数字时代手机市场的重大变化。当手机竞争从信号处理技术的竞争变成为了产品功能、方便性、新颖性及外观的竞争时，摩托罗拉等公司积累了几十年的经验就变得不那么重要了。</li>
</ul>
<h3 id="印钞机——最佳的商业模式"><a href="#印钞机——最佳的商业模式" class="headerlink" title="印钞机——最佳的商业模式"></a>印钞机——最佳的商业模式</h3><p>最好的商业模式就是印钞机式的，它不需要多少人力，一旦运作起来便能自己产生利润，持续发展。</p>
<ul>
<li>Google的广告系统：<br>传统媒体广告业主要有三项成本：①运营成本，如办报、发行、印刷的成本；②批发或零售费用，包括给广告批发商让利或支付广告销售人员的工资等；③订单处理，支付管理订单和安排广告刊登人员的工资。Google的自动化广告系统成功将后两种成本降到最低，客户自己申请登记，系统自动根据用户搜索内容匹配关键词，显示对应广告，然后自动计算费用。不需要人力管理。</li>
<li>ebay和亚马逊的在线市场<br>网络时代人们有发便地交易旧货的需求，于是ebay出现了，并收购paypal解决了网络支付问题。通过向卖家和买家收取手续费，只要做好平台的维护便可不断收钱。但是很难解决欺诈的问题，于是只向正规商家开放的Amazon出现了。</li>
<li>戴尔的虚拟工厂<br>戴尔的商业模式说白了就是将所有硬件生产外包，自己只负责订单处理和销售，将传统制造业的7个环节（产品设计、原料采购、仓储运输、加工制造、订单处理、批发经营与零售）减少到最后2个，而且采用直销手段，不经过批发零售商，大大降低成本和价格。</li>
</ul>
<h3 id="金融风暴的冲击"><a href="#金融风暴的冲击" class="headerlink" title="金融风暴的冲击"></a>金融风暴的冲击</h3><p>金融风暴就像是一场冰河期，那些常年亏损却因总体经济形势好而不倒闭的大企业就像是恐龙，在冰河时期将被彻底淘汰，那些新兴的小企业就有机会取而代之。这就是商业中的自然代谢。</p>
<h3 id="下一个Google——下一个科技浪潮"><a href="#下一个Google——下一个科技浪潮" class="headerlink" title="下一个Google——下一个科技浪潮"></a>下一个Google——下一个科技浪潮</h3><p>云计算很可能成为下一个科技浪潮，它将使用户摆脱桌面，通过浏览器，借高速网络和云端服务器，随时随地方便地享受各种应用。<br>互联网2.0目前只是互联网1.0的一种进化，仍未找到明确的商业模式，因此前景未明。</p>
<p>参考<a href="https://book.douban.com/review/5149990/" target="_blank" rel="external">网络文章</a>，加了些自己读后对理解</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/03/站在对象模型的类端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/03/站在对象模型的类端/" itemprop="url">站在对象模型的类端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-03T23:47:56+08:00">
                2015-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板的实例化"><a href="#模板的实例化" class="headerlink" title="模板的实例化"></a>模板的实例化</h2><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++标准才要求实例化他们。其原因，有两点：</p>
<ul>
<li>空间和时间效率的考虑，如果模板类中有100个成员函数，对某个特定类型只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩余的195个函数实例化将浪费大量的时间和空间。</li>
<li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li>
</ul>
<p>可以明确的要求在一个文件中将整个类模板实例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template class Point3d&lt;float&gt;;</div></pre></td></tr></table></figure>
<p>也可以显示指定实例化一个模板类的成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template float Point3d&lt;float&gt;::X() const;</div></pre></td></tr></table></figure>
<p>或是针对一个模板函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template Point3d&lt;float&gt; operator+(</div><div class="line">    const Point3d&lt;float&gt;&amp;, const Point3d&lt;float&gt;&amp; );</div></pre></td></tr></table></figure>
<p>模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。</p>
<p>模板的名称决议</p>
<p>一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of the temlate instantiation”，可以直译为“实例化模板的范围”。</p>
<p>第一种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// scope of the template definition</div><div class="line">extern double foo ( double );  </div><div class="line">    </div><div class="line">template &lt; class type &gt;  </div><div class="line">class ScopeRules  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">    void invariant() &#123;  </div><div class="line">        _member = foo( _val );  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    type type_dependent() &#123;  </div><div class="line">        return foo( _member );  </div><div class="line">    &#125;  </div><div class="line">    // ...  </div><div class="line">private:  </div><div class="line">    int _val;  </div><div class="line">    type _member;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//scope of the template instantiation  </div><div class="line">extern int foo( int );  </div><div class="line">// ...  </div><div class="line">ScopeRules&lt; int &gt; sr0;  </div><div class="line">sr0.invariant();</div><div class="line">sr0.type_dependent();</div></pre></td></tr></table></figure>
<p>在“scope of the template instantiation ”中 两个foo()都声明在此 scope中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern double foo ( double );</div></pre></td></tr></table></figure></p>
<p>看上去，应该调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int foo( int );</div></pre></td></tr></table></figure></p>
<p>毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()中调用的却在我们意料之中，调用的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int foo( int );</div></pre></td></tr></table></figure></p>
<p>诸上所述,看上去或合理或不合理的选择，原因在于:</p>
<blockquote>
<p>template 之中， 对于一个非成员名字的决议结果是根据这个 name的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互不相干，那么就以“scope of the template dclaration”来决定name。如果其使用的互相关联，那么就以“scope of the template instantiation”来决定name.</p>
</blockquote>
<p>对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场面，估计没有一个模板设计者能够hold住。相反，对于一个与实例化类型有关的名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字早在模板定义时被决议出来，那就该轮到模板的使用者hold不住了。当然所上完全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。</p>
<h2 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理(Exception Handling)"></a>异常处理(Exception Handling)</h2><p>C++的 exception handling 有三个主要的子句组成：</p>
<ul>
<li>一个throw子句。它在程序的某处丢出一个exception，被丢出的exception可以是内建类型，也可以是自定义类型。——抛出exception组件。</li>
<li>一个或多个 catch 子句。 每一个 catch 子句都是一个 exception handler。每个子句可以处理一种类型(也包括其继承类)的exception，在大括号中包含处理代码。——专治各种不服组件。每一个catch子句都可以用来处理某种exception。</li>
<li>一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出exception，从而引发catch 子句的作用。——逮捕各种 exception 组件。</li>
</ul>
<p>当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的catch子句，如果各层调用都没有吻合的catch子句，terminate()将被调用。在控制权被放弃后，堆栈中的每一个函数调用也被出栈，这个过程称为unwinding the stack(关于 stack unwinding ,可以参考《C++ Primer》第四版之 17.1.2 Stack Unwinding)，在每一个函数被出栈之前,其局部变量会被摧毁。</p>
<p>异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。解决方法之一是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void  mumble( void *arena )  </div><div class="line">&#123;  </div><div class="line">    Point *p;  </div><div class="line">    p = new Point;  </div><div class="line">    try &#123;  </div><div class="line">        smLock( arena );  </div><div class="line">        // ...  </div><div class="line">    &#125;  </div><div class="line">    catch ( ... ) &#123;  </div><div class="line">        smUnLock( arena );  </div><div class="line">        delete p;  </div><div class="line">        throw;  </div><div class="line">    &#125;  </div><div class="line">    smUnLock( arena );  </div><div class="line">    delete p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。new expression的调用不用包括在try块之内是因为，不论在new operator调用时还是构造函数调用时抛出异常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete 。</p>
<p>另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。</p>
<p>在对单个对象构造过程中抛出异常，会只调用已经构造好的base class object或member class object的析构函数。同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象构造的原则，然后释放已经分配好的内存。</p>
<p>只有在一个catch子句评估完毕并且知道它不会再抛出exception后，真正的exception object才会被释放。关于 catch子句使用引用还是使用对象来捕获异常，省略。</p>
<h2 id="执行期类型识别（Runtime-Type-Identification-RTTI）"><a href="#执行期类型识别（Runtime-Type-Identification-RTTI）" class="headerlink" title="执行期类型识别（Runtime Type Identification RTTI）"></a>执行期类型识别（Runtime Type Identification RTTI）</h2><ul>
<li>RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。</li>
<li><p>对指针进行dynamic_cast失败会返回NULL ,而对引用的话，识别会抛出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bad_cast exception。</div></pre></td></tr></table></figure>
</li>
<li><p>typeid 可以返回const type_info&amp;，用以获取类型信息。<br>关于1是因为RTTI的实现是通过vptr来获取存储在虚函数表中的type_info* ，事实上为非多态类提供RTTI,也没有多大意义。 2的原因在于指针可以被赋值为0，以表示 no object，但是引用不行。关于3，虽然第一点指出RTTI只支持多态类，但typeid和type_info同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的type_info对象是静态取得(所以不能叫“执行期类型识别”)，而多态类的是在执行期获得。</p>
</li>
</ul>
<p>参考：深度探索C++对象模型</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/构造、解构、拷贝 语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/构造、解构、拷贝 语意学/" itemprop="url">构造、解构、拷贝 语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T23:41:22+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="几点类设计原则"><a href="#几点类设计原则" class="headerlink" title="几点类设计原则"></a>几点类设计原则</h2><ul>
<li><p>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。</p>
</li>
<li><p>不要将析构函数设计为纯虚的，这不是一个好的设计。将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。一个不能派生继承类的抽象类有什么存在的意义？必须定义纯虚析构函数，而不能仅仅声明它的原因在于：每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的析构函数声明，则去调用它的实体，而不管它有没有被定义。</p>
</li>
<li><p>真的必要的时候才使用虚函数，不要滥用虚函数。虚函数意味着不小的成本，编译很可能给你的类带来膨胀效应：</p>
<ul>
<li>每一个对象要多负担一个word的vptr。</li>
<li>给每一个构造函数（不论是显示的还是编译器合成的），插入一些代码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前。没有构造函数则需要合成，并插入代码。</li>
<li>合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对vptr的初始化代码，有的话也需要插入vptr的初始化代码。</li>
<li>意味着，如果具有bitwise语意，将不再具有，然后是变大的对象、没有那么高效的构造函数，没有那么高效的复制控制。</li>
</ul>
</li>
<li><p>不能决定一个虚函数是否需要 const ，那么就不要它。</p>
</li>
<li><p>决不在构造函数或析构函数中使用虚函数机制。在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。这是由vptr初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p>
</li>
</ul>
<h2 id="构造、复制、析构语意学"><a href="#构造、复制、析构语意学" class="headerlink" title="构造、复制、析构语意学"></a>构造、复制、析构语意学</h2><p>一种所谓的Plain OI’Data声明形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    float x,y,z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>概念上来讲，对于一段这样的C++代码,编译器会为之合成一个默认构造函数、复制构造函数、析构函数、赋值操作符。然而实际上编译器会分析这段代码，并给Point贴上Plain OI’Data标签。编译器在此后对于Point的处理与在C中完全一样,也就是说上述的函数都不会被合成。可见概念上应当由编译器合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。由此一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的方法来完成上面的功能，比方复制控制会用bitwise copy。</p>
<h3 id="对象构造语意学"><a href="#对象构造语意学" class="headerlink" title="对象构造语意学"></a>对象构造语意学</h3><h3 id="无继承情况下的对象构造：略。"><a href="#无继承情况下的对象构造：略。" class="headerlink" title="无继承情况下的对象构造：略。"></a>无继承情况下的对象构造：略。</h3><h4 id="单继承体系下的对象构造"><a href="#单继承体系下的对象构造" class="headerlink" title="单继承体系下的对象构造"></a>单继承体系下的对象构造</h4><p>对于简单定义的一个对象T object;,很明显它的默认构造函数会被调用（被编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作：</p>
<ul>
<li><p>调用所有虚基类的构造函数，从左到右，从最深到最浅：</p>
<ul>
<li>如果该类被列于成员初始化列表中，任何明确明确指定的参数，都应该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构造函数被调用（有的话）。</li>
<li>此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现虚基类的编译器来说，满足这点要求就是对vbptr的初始化。</li>
<li>然而，只有在类对象代表着“most-derived class”时，这些构造函数才可能会被调用。一些支持这个行为的代码会被放进去^注2（直观点说就是，虚基类的构造由最外层类控制)。</li>
</ul>
</li>
<li><p>调用所有基类构造函数，依声明顺序：</p>
<ul>
<li>如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该被传递过来。</li>
<li>没有列入的话，那么调用其默认构造函数，如果有的话。</li>
<li>如果该基类是第二顺位或之后的基类，this 指针必须被调整。</li>
</ul>
</li>
<li><p>正确初始化vptr,如果有的话。</p>
</li>
<li>调用没有出现在初始化成员列表中的member object的默认构造函数，如果有的话。</li>
<li>记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函数中。</li>
</ul>
<h4 id="虚拟继承下的构造抑制"><a href="#虚拟继承下的构造抑制" class="headerlink" title="虚拟继承下的构造抑制"></a>虚拟继承下的构造抑制</h4><p>有如下继承体系：</p>
<p><img src="/images/cpp/cpp_10.png" alt=""></p>
<p>根据c++ 语法，Point 的初始化应有most-derived class来施行。也就是说当Vertex3d为most-derived class的时候，应当由它的构造函数来调用Point的构造函数初始化Point子对象，Vertex3d的子对象的构造函数对于Point的调用则应当抑制。如果没有抑制会怎么样?当我们定义Vertex3d cv;时，Vertex3d的构造函数中调用Point的构造函数、而随之调用它的子对象，Point3d和Vertex的<br>构造函数中也调用了Point的构造函数。先不说，对于同一个子对象进行三次初始化是否有效率，更重要的是，这将不可避免的带来错误。由Vertex3d指定的子对象Point的值，会被覆盖掉。</p>
<p>编译器通常使用一个条件变量来表示是否为most-derived class,各构造函数根据这个条件变量来决定是否调用虚基类的构造函数，因此通过控制这个条件变量，就可以抑制非most-derived class调用虚基类的构造函数。当然也有其它的方法来做同样的事。</p>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><p>设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：</p>
<ul>
<li>什么都不做，采用编译器提供默认行为（bitwise copy或者由编译器合成一个）。</li>
<li>自己提供一个赋值运算符操作。</li>
<li>明确拒绝将一个对象指定给另一个对象。<br>对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。对于第二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时候。</li>
</ul>
<p>以下四种情况 copy assignment operator(还是用它的英文名，感觉顺畅点)，不具有bitwise copy语意，也就是说这些情况下，编译器要合成copy assignmentoperator而不能依靠bitwise copy来完成赋值操作，这四种情况与构造函数、拷贝构造函数的情况类似，原因可以参考它们的。四种情况如下：</p>
<ul>
<li>类包含有定义了copy assignment operator的class object成员。</li>
<li>类的基类有copy assignment operator。</li>
<li>类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝的时候）。</li>
<li>当class继承体系中有虚基类时。<br>在虚拟继承情况下，copy assignment opertator会遇到一个不可避免的问题，virtual base class subobject的复制行为会发生多次，与前面说到的在虚拟继承情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derivedclass 对virtual base class 的赋值行为。</li>
</ul>
<p>安全的做法是把虚基类的赋值放在最后，避免被覆盖。</p>
<h3 id="对象析构语意学"><a href="#对象析构语意学" class="headerlink" title="对象析构语意学"></a>对象析构语意学</h3><p>只有在基类拥有析构函数，或者object member拥有析构函数的时候，编译器才为类合成析构函数，否则都被视为不需要。</p>
<p>析构的顺序正好与构造相反：</p>
<ul>
<li>本身的析构函数被执行。</li>
<li>以声明的相反顺序调用member object 的析构函数，如果有的话。</li>
<li>重设vptr 指向适当的基类的虚函数表，如果有的话。</li>
<li>以声明相反的顺序调用上一层的析构函数，如果有的话。</li>
<li>如果当前类是 most-derivedclass，那么以构造的相反顺序调用虚基类的析构函数。</li>
</ul>
<p>“在此之前”的叙述并不适合我，我喜欢很直白的方式，按顺序来。书中的方式在于，从最浅显的步骤入手，然后告诉你，做这步之前，你还该做点什么。所以，我以对原文的理解写下这点。Lippman的原文为：</p>
<blockquote>
<p>These constructors, however, may be invoked if, and only if, the class object represents the “most-derived class.” Some mechanism supporting this must be put into place.</p>
</blockquote>
<p>侯捷的译文为：</p>
<blockquote>
<p>如果class object是最底层（most-derived）的class,其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。</p>
</blockquote>
<p>我认为，Lippman在这一句上要说的是，虚基类的构造函数只能由most-derived class调用，而为了支持这一机制，需要插入一些代码来抑制非most-derived class对虚基类构造函数的调用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/执行期语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/执行期语意学/" itemprop="url">执行期语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T20:27:34+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="new-expression、operator-new-和-placement-new"><a href="#new-expression、operator-new-和-placement-new" class="headerlink" title="new expression、operator new 和 placement new"></a>new expression、operator new 和 placement new</h2><p>之前虽然一直知道有new expression、operator new和placement new，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new和delete，特意结合《C++ Primer》写下这篇笔记，以作总结。三个虽然都是new，但每个new都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个“new”，但期间也不忘提一提推倒这三个“new”的哥们——delete。</p>
<p>new expression 和 operator new</p>
<p>一个看起来很简单的new expression运算，其实暗含一些步骤，像这样的一次简单运用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *p=new int (5)实际上包含着两个步骤：</div></pre></td></tr></table></figure></p>
<ul>
<li>调用一个合适的operator new实体分配足够的未类型化的内存。</li>
<li>调用合适的构造函数初始化这块内存，当然int没有构造函数，但是会进行赋值操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*p=5。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可见：new expression和operator new完全不是一回事，但关系不浅——operator new 为new expression分配内存。</p>
<p>摘录一下 《C++ primer》关于对比new expression 和 operator new的一小段话：</p>
<blockquote>
<p>标准库函数 operator new和 operator delete 的命名容易让人误解。与其他operator 函数（如 operator=）不同，这些函数没有重载new或delete expression，实际上，我们不能重定义new或delete expression的行为。</p>
</blockquote>
<p>这段话有两个要点：</p>
<ul>
<li>operator new和operator delete不是new expression和delete expression的重载，它们完全是另外的一个独立的东西，具有不同的语意，这与operator +是对+ expression的重载不同。</li>
<li>new expression和delete expression是不能被重载的，可以看出它们与普通的expression 不同。</li>
<li>operator new其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用operator new 来进行。用法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T* newelements = static_cast&lt;T*&gt;(operator new ( sizeof(T) );</div></pre></td></tr></table></figure>
<p>标准库重载有两个版本的operator new，分别为单个对象和数组对象服务，单个对象版本的<br>提供给分配单个对象new expression调用，数组版的提供给分配数组的 new expression 调<br>用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void *operator new(size_t);       // allocate an object</div><div class="line">void *operator new[](size_t);     // allocate an array</div></pre></td></tr></table></figure></p>
<p>我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operator new时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个void*类型和第一个参数的类型必须为size_t。</p>
<p>还要注意的是，在类中重载的operator new和operator delete是隐式静态的，因为前者运行于对象构造之前，后者运行与对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据。另外，new expression 默认调用的是单参数的operator new——上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p>
<p>delete expression与new expression相对应，而operator delete则与operator new对应。<br>依上所述，则不难推断出关于delete expression和operator delete之间的关系以及一些特性，此略。</p>
<p>当使用new expression来动态分配数组的时候，Lippman在《深度探索C++对象模型》中指出：</p>
<ul>
<li>当分配的类型有一个默认构造函数的时候，new expression将调用一个所谓的vec_new()函数来分配内存，而不是operator new内存。但我在VC ++ 20102上测试的结果却是，不论有没有构造函数，new expression都是调用operator new来分配内存，并在此之后，调用默认构造函数逐个初始化它们，而不调用所谓的vec_new()，也许cfront确实离我们有点遥远。</li>
</ul>
<h2 id="两个-delete-后的问题"><a href="#两个-delete-后的问题" class="headerlink" title="两个 delete 后的问题"></a>两个 delete 后的问题</h2><p>最近在网上看到两个关于指针 delete 后的问题。第一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int;</div><div class="line">delete p;</div><div class="line">delete p;// p为什么能delete两次，而程序运行的时候还不报错。</div></pre></td></tr></table></figure></p>
<p>第二种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int ;</div><div class="line">delete p;</div><div class="line">*p = 5;     //delete后对*p进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？</div></pre></td></tr></table></figure></p>
<p>在回答这两个问题之前，我们先想想delete p; 这一语句意味着什么？p指向一个地址，以该地址为起始地址保存有一个int变量（虽然该变量并没有进行初始化），delete p之后p所指向的地址空间被释放，也就是说这个int变量的生命结束，但是p仍旧是一个合法的指针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与delete之前唯一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？你租了一间储物室（int* p = new int;），后来退租了（delete p;），但你却保存了出入该储物室的钥匙（指针p）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。<br>但是：你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这<br>个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再之后各种难以预料的情况就会发生。</p>
<p>又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾出空间来放你的。</p>
<p>回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大<br>的逻辑错误，不论你对一块已经释放的内存再度delete，还是再度给它赋值，都暗含着很大<br>的危险，因为当你delete后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再<br>度分配出去，此时不论是你再度delete还是重新赋值，都将破坏其它代码的数据，同时你存<br>储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，这取决于有一个怎么样的“房东”，<br>聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。</p>
<p>上述情况下的指针p被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的<br>内存。避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为NULL，其缘由在<br>于，你可以很容易的判断一个指针是否为NULL,却难以抉择其是否为野指针。而且，delete<br>一个空指针，不会做任何操作，因此总是安全的。</p>
<h2 id="不用一个基类指针指向派生类数组？"><a href="#不用一个基类指针指向派生类数组？" class="headerlink" title="不用一个基类指针指向派生类数组？"></a>不用一个基类指针指向派生类数组？</h2><p>《深度探索C++对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的cfront中的vec_delete是根据被删除指针的类型来调用析构函数——也就是说虚函数机制在这儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。我在vc++2008和vc++ 2010下的结果是：是的，有与cfront不同，它支持多态。</p>
<p>我的测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class point&#123;</div><div class="line">public:</div><div class="line">        virtual ~point()&#123;</div><div class="line">            std::cout&lt;&lt;&quot;point::~point()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int  a;</div><div class="line">&#125;;</div><div class="line">class point3d:public point&#123;</div><div class="line">public:</div><div class="line">    virtual ~point3d()</div><div class="line">        &#123;</div><div class="line">            std::cout&lt;&lt;&quot;point3d::~point3d()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int b;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    point *p=new point3d[2];</div><div class="line">    delete[] p;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">&#125; ;</div></pre></td></tr></table></figure>
<p>输出的结果，也令人满意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div></pre></td></tr></table></figure>
<p>确实调用了派生类的析构函数，而非基类的析构函数。</p>
<p>即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。非得这么做？那么我认为delete的时候将之类类型转换为派生类就差不多了，可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete[] static_cast&lt;point3d*&gt;(p);</div></pre></td></tr></table></figure>
<p>似乎不必要像Lippman说的这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( int ix = 0; ix &lt; elem_count; ++ix ) </div><div class="line">&#123;  </div><div class="line">    Point3d *p = &amp;((Point3d*)ptr)[ ix ];  </div><div class="line">    delete p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="placement-operator-new"><a href="#placement-operator-new" class="headerlink" title="placement operator new"></a>placement operator new</h2><p>placement operator new用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是对指定地址调用构造函数。其调用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point3d;</div></pre></td></tr></table></figure></p>
<p>观其名字可知，它是operator new的一个重载版本。它的实现方式异常简单，传回一个指针即 可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void* operator new(site_t,void *p)</div><div class="line">&#123;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman告诉我们，它有另一半重要的工作是被扩充而来。我在想，扩充一个类中定义的placement operator new还好说，但是要如何 扩充一个库中提供的placement operator new呢？毕竟它要放之四海而皆准，我原以为这其中 有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement operator new 也并不强 大。</p>
<p>我先明确调用了 placement operator new ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=(point*)operator new(sizeof(point), p) ;</div></pre></td></tr></table></figure></p>
<p>如我所料，输出结果显示（我在point的默认构造函数和placement operator new中间各输 出一句不同的话），此时 point的默认构造函数并不会被调用。然后我通过new expression 的方式来间接调用placement operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point();</div></pre></td></tr></table></figure></p>
<p>这个时候 point 的默认的构造函数被调用了。可见 placement operator new并没有什么奇特 的地方，它与一般的operator new不同处在于，它不会申请内存。它也不会在指定的地址调用 构造函数，而调用构造函数的的全部原因在于new expression总是先调用一个匹配参数的 operator new然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new 也是一个operator new。</p>
<p>通过一个placement operator new构建的一个对象，如果你使用delete来撤销对象，那么其内 存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。</p>
<p>看一份代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Base &#123; int j; virtual void f(); &#125;;</div><div class="line">struct Derived : Base &#123; void f(); &#125;;</div><div class="line">void fooBar() &#123;  </div><div class="line">   Base b;  </div><div class="line">   b.f(); // Base::f() invoked  </div><div class="line">   b.~Base();  </div><div class="line">   new ( &amp;b ) Derived; // 1  </div><div class="line">   b.f(); // which f() invoked?  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述两个类的大小相同，因此将Derived对象放在 Base对象中是安全的，但是在最后一句代码 中 b.f()调用的是哪一个类的f()。答案是Base::f() 的。虽然此时b中存储的实际上是一个 Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。</p>
<p>参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/Function语意学（The-Semantics-of-Function）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/Function语意学（The-Semantics-of-Function）/" itemprop="url">Function语意学（The Semantics of Function）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T23:23:39+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-之成员函数调用"><a href="#C-之成员函数调用" class="headerlink" title="C++之成员函数调用"></a>C++之成员函数调用</h2><p>c++支持三种类型的成员函数，分别为<code>static</code>,<code>nostatic</code>,<code>virtual</code>。每一种调用方式都不尽相同。</p>
<h3 id="非静态成员函数（Nonstatic-Member-Functions）"><a href="#非静态成员函数（Nonstatic-Member-Functions）" class="headerlink" title="非静态成员函数（Nonstatic Member Functions）"></a>非静态成员函数（Nonstatic Member Functions）</h3><p>保证nostatic member function至少必须和一般的nonmember function有相同的效率是C++的设计准则之一。事实上在c++中非静态成员函数（nostatic member function）与普通函数的调用也确实具有相同的效率，因为本质上非静态成员函数就如同一个普通函数,如一个非静态成员函数Xfloat Point::X();就相当于一个普通函数float X(Point* this);。编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p>
<ul>
<li>改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">float Point::X();</div><div class="line">//成员函数X被插入额外参数this</div><div class="line">float Point:: X(Point* this );</div><div class="line">当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</div></pre></td></tr></table></figure>
<ul>
<li><p>将每一个对非静态数据成员的操作都改写为经过this操作。</p>
</li>
<li><p>将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p>
</li>
</ul>
<p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p>
<p>由此可以做出一点总结：一个成员函数实际上就是一个被插入了一个接受其类的指针类型的额外参数的非成员函数，当然还要额外对函数的名称进行处理。额外插入的参数用来访问数据成员，而名称的特殊处理用来避免名字冲突。</p>
<p>对于名称的特殊处理并没有统一的标准，各大编译器厂商可能有不同的处理规则。在VC下上述的成员函数X()的名称X处理后就成了<code>?X@Point@@QAEMXZ</code>更多信息可以参见维基百科的Visual C++名字修饰。</p>
<p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//p-&gt;X();被转化为</div><div class="line">?X@Point@@QAEMXZ(p);</div><div class="line">//obj.X();被转化为</div><div class="line">?X@Point@@QAEMXZ(&amp;obj);</div></pre></td></tr></table></figure>
<h3 id="虚拟成员函数-Virtual-Member-Functions"><a href="#虚拟成员函数-Virtual-Member-Functions" class="headerlink" title="虚拟成员函数(Virtual Member Functions)"></a>虚拟成员函数(Virtual Member Functions)</h3><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// p-&gt;function()</div><div class="line">//将转化为</div><div class="line">(*p-&gt;vptr[1])(p);</div></pre></td></tr></table></figure>
<ul>
<li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li>
<li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().<br>何时发生这种转换？答案是在必需的时候——一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。</li>
</ul>
<h3 id="静态成员函数-Static-Member-Functions"><a href="#静态成员函数-Static-Member-Functions" class="headerlink" title="静态成员函数(Static Member Functions)"></a>静态成员函数(Static Member Functions)</h3><p>静态成员函数的一些特性：</p>
<ul>
<li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li>
<li>不能够声明为 const、voliatile或virtual。</li>
<li>它不需经由对象调用，当然，通过对象调用也被允许。<br>除了缺乏一个this指针他与非静态成员函数没有太大的差别。在这里通过对象调用和通过指针或引用调用，将被转化为同样的调用代码。</li>
</ul>
<p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(a+=b).static_fuc();</div></pre></td></tr></table></figure>
<p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间。这无疑是一个明智的规定。</p>
<h2 id="C-之虚函数-Virtual-Member-Functions"><a href="#C-之虚函数-Virtual-Member-Functions" class="headerlink" title="C++之虚函数(Virtual Member Functions)"></a>C++之虚函数(Virtual Member Functions)</h2><p>《深度探索C++对象模型》是这样来说多态的:</p>
<p>在C++中,多态表示“以一个public base<br>class的指针（或引用），寻址出一个derived class object”的意思。</p>
<h3 id="消极多态与积极多态"><a href="#消极多态与积极多态" class="headerlink" title="消极多态与积极多态"></a>消极多态与积极多态</h3><p>用基类指针来寻址继承类的对象，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point ptr=new Point3d;               //Point3d继承自Point</div></pre></td></tr></table></figure>
<p>在这种情况下，多态可以在编译期完成（虚基类情况除外），因此被称作消极多态（没有进行虚函数的调用）。相对于消极多态，则有积极多态——指向的对象类型需要在执行期在能决定。积极多态的例子如虚函数和RTTI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//例1，虚函数的调用</div><div class="line">ptr-&gt;z();</div><div class="line">//例2，RTTI 的应用</div><div class="line">if(Point3d *p=dynamic_cast&lt;Point3d*&gt;(ptr) )</div><div class="line">	return p-&gt;z();</div></pre></td></tr></table></figure>
<p>关于RTTI的笔记可见笔记EH &amp; RTTI。本文主要精力将集中于虚函数上。对于一个如上例关于虚函数的调用，要如何来保证在执行期调用的是正确的z()实体——Point3d::z()而不是调用了Point::z()。来看看虚函数的实现机制吧，它将保证这一点。</p>
<h3 id="单继承下的虚函数"><a href="#单继承下的虚函数" class="headerlink" title="单继承下的虚函数"></a>单继承下的虚函数</h3><p>虚函数的实现：</p>
<ul>
<li>为每个有虚函数的类配一张虚函数表，它存储该类类型信息和所有虚函数执行期的地址。</li>
<li>为每个有虚函数的类插入一个指针（vptr）,这个指针指向该类的虚函数表。</li>
<li>给每一个虚函数指派一个在表中的索引。<br>用这种模型来实现虚函数得益于在C++中,虚函数的地址在编译期是可知的，而且这一地址是固定不变的。而且表的大小不会在执行期增大或减小。</li>
</ul>
<p>一个类的虚函数表中存储有类型信息（存储在索引为0的位置）和所有虚函数地址，这些虚函数地址包括三种：</p>
<ul>
<li>这个类定义的虚函数，会改写（overriding）一个可能存在的基类的虚函数实体——假如基类也定义有这个虚函数。</li>
<li>继承自基类的虚函数实体，——基类定义有，而这个类却没有定义。直接继承之。</li>
<li>一个纯虚函数实体。用来在虚函数表中占座，有时候也可以当做执行期异常处理函数。<br>每一个虚函数都被指派一个固定的索引值，这个索引值在整个继承体系中保持前后关联，例如,假如z()在Point虚函数表中的索引值为2，那么在Point3d虚函数表中的索引值也为2。</li>
</ul>
<p>当一个类单继承自有虚函数的基类的时候，将按如下步骤构建虚函数表：</p>
<ul>
<li>继承基类中声明的虚函数——这些虚函数的实体地址被拷贝到继承类中的虚函数表中对于的slot中。</li>
<li>如果有改写（override）基类的虚函数，那么在1中应将改写（override）的函数实体的地址放入对应的slot中而不是拷贝基类的。</li>
<li>如果有定义新的虚函数，那么将虚函数表扩大一个slot以存放新的函数实体地址。<br>我们假设z()函数在Point虚函数表中的索引为4，回到最初的问题——要如何来保证在执行期调用的是正确的z()实体？其中微妙在于，编译将做一个小小的转换:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;z();</div><div class="line">//被编译器转化为：</div><div class="line">(*ptr-&gt;vptr[4])(ptr);</div></pre></td></tr></table></figure>
<p>这个转换保证了调用到正确的实体，因为：</p>
<ul>
<li>虽然我们不知道ptr所指的真正类型,但它可以通过vptr找到正确类型的虚函数表。</li>
<li>在整个继承体系中z()的地址总是被放在slot 4。</li>
</ul>
<h3 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h3><p>在多重继承下，继承类需要为每一条继承线路维护一个虚函数表（也有可能这些表被合成为一个，但本质意义并没有变化）。当然这一切都发生在需要的情况下。</p>
<p>当使用第一继承的基类指针来调用继承类的虚函数的时候，与单继承的情况没有什么异样，问题出生在当以第二或后继的基类指针（或引用）的使用上。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//假设有这样的继承关系：class Derived:public base1,public base2;</div><div class="line">//base1,base2都定义有虚析构函数。</div><div class="line">base2 *ptr = new derived;</div><div class="line">//需要被转换为，这个转换在编译期完成</div><div class="line">base2 *ptr = temp ? temp + sizeof(base1) : 0 ;</div></pre></td></tr></table></figure>
<p>如果不做出上面的转换，那么 ptr 指向的并不是 derived 的 base2 subobject。后果是，ptr 将一个derived类型当做base2类型来用。</p>
<p>当要delete ptr时又面临了一次转换，因为在delete ptr的时候，需要对整个对象而不是其子对象施行delete运算符，这期间需要调整ptr指向完整的对象起点，因为不论是调用正确的析构函数还是delete运算符都需要一个指向对象起点的指针，想一想给予一个derived类的成员函数指向base2 subobjuect 的this指针会发生什么吧。因为ptr的具体类型并不知道，所以必须要等到执行期来完成。</p>
<p>Bjame的解决方法是将每一个虚函数表的slot扩展，以使之存放一个额外的偏移量。于是虚函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(*ptr-&gt;vptr[1])(ptr);</div><div class="line">//将变成：</div><div class="line">(*ptr-&gt;vptr[1].addr)(ptr+*ptr-&gt;vptr[1].offset);</div></pre></td></tr></table></figure></p>
<p>其中使用ptr-&gt;vptr[1].addr用以获取正确的虚函数地址，而ptr+*ptr-&gt;vptr[1].offset来获得指向对象完整的起点。这种方法的缺点显而易见，代价过大了一点，所有的情况都被这一种占比较小的情况拖累。</p>
<p>还有一种叫做thunk的方法，thunk的作用在于:</p>
<ul>
<li>以适当的offset值来this调整指针.</li>
<li>跳到虚函数中去。</li>
</ul>
<p>Thunk技术即是：虚函数表中的slot仍然继续放一个虚函数实体地址，但是如果调用这个虚函数需要进行this调整的话,该slot中的地址就指向一个Thunk而不是一个虚函数实体的地址。</p>
<p>书中纷杂的讲到不少中种情况，但我以我的理解，做如下小结：</p>
<p>多继承下的虚函数，影响到虚函数的调用的实际质上为this的调整。而this调整一般为两种：</p>
<ul>
<li>调整指针指向对应的subobject，一般发生在继承类类型指针向基类类型指针赋值的情况下。</li>
<li>将指向subobject的指针调整回继承类对象的起始点，一般发生在基类指针对继承类虚函数进行调用的时候。</li>
</ul>
<p>第一点，使得该基类指针指向一个与其指针类型匹配的子对象，唯有如此才能保证使得该指针在执行与其指针类型相匹配的特定行为的正确性。比方调用基类的成员，获得正确的虚函数地址。可以想象如果不调整，用ptr存取base2 subobject的数据成员时，会发生什么？调用base2的成员函数的时候，其成员函数接受的this指针指向derived类型对象，这又会发生什么？结果是整个对象的内存结构有可能都被破坏。还有别忘了，vptr也可以看做一个数据成员，要找到虚函数，前提是获取正确的vptr偏移量。</p>
<p>而第二点，显然是让一个继承类的虚函数获取一个正确的this指针，因为一个继承类虚函数要的是一个指向继承类对象的this指针，而不是指向其子对象。</p>
<p>第一顺序继承类之所以不需要进行调整的关键在于，其subobject的起点与继承类对象的起点一致。</p>
<h3 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h3><p>Lippman说，如果一个虚基类派生自另一虚基类，而且它们都支持虚函数和非静态数据成员的时候，编译器对虚基类的支持就像迷宫一样复杂。</p>
<p>虽然书中没有介绍太多，但不难猜测的是在虚继承情况下，复杂点在仍旧在于this指针的调整，然而其复杂度显然又在多继承之上，因为又多了一个vbptr了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/03/02/Data语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/02/Data语意学/" itemprop="url">Data 语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-02T23:03:46+08:00">
                2015-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-类对象的大小"><a href="#C-类对象的大小" class="headerlink" title="C++类对象的大小"></a>C++类对象的大小</h2><h3 id="一个实例引出的思考"><a href="#一个实例引出的思考" class="headerlink" title="一个实例引出的思考"></a>一个实例引出的思考</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;&#125;;</div><div class="line">class Y:virtual public X&#123;&#125;;</div><div class="line">class Z:virtual public X&#123;&#125;;</div><div class="line">class A:public Y, public Z&#123;&#125;;</div></pre></td></tr></table></figure>
<p>猜猜sizeof上面各个类都为多少？</p>
<p>Lippman的一个法国读者的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof X yielded 1                         </div><div class="line">sizeof Y yielded 8                         </div><div class="line">sizeof Z yielded 8                         </div><div class="line">sizeof A yielded 12</div></pre></td></tr></table></figure></p>
<p>我在vs2012上的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sizeof X yielded 1   </div><div class="line">sizeof Y yielded 4   </div><div class="line">sizeof Z yielded 4    </div><div class="line">sizeof Z yielded 8</div></pre></td></tr></table></figure></p>
<p>当我们对于C++对象的内存布局知之甚少的情况下，想搞清这些奇怪现象的缘由将是一件非常困难的事情。不过下文会为你一一解惑。</p>
<p>事实上，对于像X这样的一个的空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p>
<p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p>
<p>alignment[^注1]会将数值调整到某数的整数倍，32位计算机上位4bytes。内存对齐可以使得总线的运输量达到最高效率。所以Y、Z的大小被补齐到8就不足为奇了。</p>
<p>那么在vs2012中为什么Y、Z的大小是4而不是8呢？我们先思考一个问题，X之所以被插入1字节是因为本身为空，需要这一个字节为其在内存中给它占领一个独一无二的地址。但是当这一字节被继承到Y、Z后呢？它已经完全失去了它存在的意义，为什么？因为Y、Z各自拥有一个虚基类指针，它们的大小不是0。既然这一字节在Y、Z中毫无意义，那么就没必要留着。也就是说vs2010对它们进行了优化，优化的结果是去掉了那一个字节,而Lippman的法国读者的编译器显然没有做到这一点。</p>
<p>当我们现在再来看A的时候，一切就不是问题了。对于那位Lippman的法国读者来说，A的大小是共享的X实体1字节,X和Y的大小分别减去虚基类带来的内存空间，都是4。A的总计大小为9，alignment以后就是12了。而对于vs2010来说，那个一字节被优化后，A的大小为8，也不需再进行alignment操作。</p>
<h3 id="影响C-类的大小的三个因素："><a href="#影响C-类的大小的三个因素：" class="headerlink" title="影响C++类的大小的三个因素："></a>影响C++类的大小的三个因素：</h3><ul>
<li>支持特殊功能所带来的额外负担（对各种virtual的支持）。</li>
<li>编译器对特殊情况的优化处理。</li>
<li>alignment操作，即内存对齐。[关于更多的memory alignment（内存对齐）的知识见VC内存对齐准则（Memory alignment）]</li>
</ul>
<h2 id="VC内存对齐准则（Memory-alignment）"><a href="#VC内存对齐准则（Memory-alignment）" class="headerlink" title="VC内存对齐准则（Memory alignment）"></a>VC内存对齐准则（Memory alignment）</h2><p>本节所有内容在建立在一个前提下：使用VC编译器。着重点在于：VC的内存对齐准则；同样的数据，<br>不同的排列有不同的大小，另外在有虚函数或虚拟继承情况下又有如何影响？</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>对于一台32位的机器来说如何才能发挥它的最佳存取效率呢？当然是每次都读4字节（32bit）,这样才可以让它的bus处于最高效率。实际上它也是这么做的，即使你只需要一个字节，它也是读一个机器字长（这儿是32bit）。更重要的是，有的机器在存取或存储数据的时候它要求数据必须是对齐的，何谓对齐？它要求数据的地址从4的倍数开始，如若不然，它就报错。还有的机器它虽然不报错，但对于一个类似int变量，假如它横跨一个边界的两端，那么它将要进行两次读取才能获得这个int值。比方它存储在地址为2~5的四个字节中，那么要读取这个int，将要进行两次读取，第一次读取0~3四个字节，第二次读取4~7四个字节。但是如果我们把这个整形的起始地址调整到0,4,8…呢？一次存取就够了！这种调整就是内存对齐了。我们也可以依次类推到16位或64位的机器上。</p>
<h3 id="边界该如何调整"><a href="#边界该如何调整" class="headerlink" title="边界该如何调整"></a>边界该如何调整</h3><p>对于32位的机器来说，它当然最渴望它的数据的大小都是4 Byte或者4的倍数Byte，这样它就能最有效率的存取数据，当然如果数据小于4Byte,那也是没问题的。那么编译器要做的便是尽量满足这个要求。</p>
<p>这两天我断续对VC做了一些实验，并总结如下三条准则，你要明白的是这并非来自微软的官方文档，但我自以为这些准则或许不全但应该都是正确的：</p>
<ul>
<li>变量存放的起始位置^注2应为变量的大小与规定对齐量[^注1]中较小者的倍数。例如，假设规定对齐量为4，那么char（1byte）变量应该存储在偏移量为1的倍数的地方，而整形变量（4byte）则是从偏移量为4的倍数的地方，而double（8 byte）也同样应存储在偏移量为4的倍数的地方，为什么不是8？因为规定对齐量默认值为4，而4 &lt; 8。在VC中默认对齐量为8，而非4。</li>
<li>结构体整体的大小也应该对齐，对齐依照规定对齐量与最大数据成员两者中较小的进行。</li>
<li>Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响。一个实例</li>
</ul>
<p>对于类T：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class T &#123;</div><div class="line">    char c;</div><div class="line">    int i;</div><div class="line">    double  d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将其sizeof输出后的大小为16，其内存布局如图T.变量c从偏移量为0开始存储，而整形i第一个符号条件的偏移量为4，double型d的第一个符号条件的为8。整个对象的大小为16，不需要再进行额外的对齐。</p>
<p>类T 的内存布局<br><img src="/images/cpp/cpp_8.png" alt=""></p>
<p>同样的数据，不同的大小</p>
<p>再看类L,它与T存储同样类型的数据，仅仅是顺序不同罢了，那么它sizeof输出的大小是多少呢?</p>
<p>类L:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class L &#123;</div><div class="line">    char c;</div><div class="line">    double  d;</div><div class="line">    int i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它sizeof后的结果或许会令你大吃一惊，或许不会（如果你有认真读前面的两条准则）。Lsizeof后的结果是24！同样是一个int，一个char，一个double却整整多出了8个字节。这期间发生了什么？我们依据前面两条规则来看看。C存储于0的位置，1~7都不能整除8，所以d存储在8~15，16给i正好合适，i存储在16~19。总共花费了20个字节，抱歉不是8的倍数，还得补齐4个。现在你可以看看图L的关于类L的内存布局，再比较一下类L和类T的内存布局。</p>
<p>图L(类L的布局)<br><img src="/images/cpp/cpp_9.png" alt=""></p>
<p>我得出了这样一条并不权威的结论，因为我还没听有人这样说过：在声明数据成员的时候，将最大字节数的变量放在最前面[^注3],切忌不要将大小差距很大的类型交替声明。</p>
<h3 id="Vptr影响对齐而VbcPoint-Virtual-base-class-pointer-不影响"><a href="#Vptr影响对齐而VbcPoint-Virtual-base-class-pointer-不影响" class="headerlink" title="Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响"></a>Vptr影响对齐而VbcPoint(Virtual base class pointer)不影响</h3><p>前面的实例只涉及前两条准则，现在我们来看看第三条的两个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class X&#123;char a;&#125;;</div><div class="line">class Y: virtual public X&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>Y的大小为:a占一个字节，VbcPoint（我称他为虚基类指针）占四个字节。我们不论a与VbcPoint的位置如何摆放，如果将VbcPoint等同于一个成员数据来看的话，sizeof(Y)都应该为8.实际上它是5！就我目前的水平，我只能先将其解释为VbcPoint不参与对齐。</p>
<p>对于vptr这个问题则不存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">    char a;</div><div class="line">    virtual int vfc()&#123;&#125;;&#125;</div><div class="line">sizeof（X）的大小确实为8.</div></pre></td></tr></table></figure>
<p>关于#pragma pack(n)</p>
<p>用#pragma pack(n)改变规定对齐量试试眨眼。</p>
<p>使我确信从大到小排列好于从小到大排列的理由在于，从大到小排列一般无需成员之间的对齐，唯一的对齐工作是最后进行的整个结构体对齐的工作。毫无疑问的是，这应该是最节省内存的方式。再之后，独酌提出从小到大可能好些，虽然没有给出有说服力的理由，但却使我无比困惑，我当时虽然认为从大到小的排列更有优势，但却实在想不出一个实例能使得它优于从小到大排列的。不过最终我击垮了自己的理由，在继承状况下从大到小排列很容易被打破，比方，基类的成员为一个char,继承类的成员为double,int,char虽然基类和继承类都是按从大到小的顺序排列的，但是继承类的内存布局最终会使char,double,int,char，此时既不能避免成员对齐，又导致后面的结构体对齐。暂时获得的最终结果是从小到大排列是更好的一种排列方式。</p>
<h2 id="C-对象的数据成员"><a href="#C-对象的数据成员" class="headerlink" title="C++对象的数据成员"></a>C++对象的数据成员</h2><h3 id="数据成员的布局"><a href="#数据成员的布局" class="headerlink" title="数据成员的布局"></a>数据成员的布局</h3><p>对于一个类来说它的对象中只存放非静态的数据成员,但是除此之外，编译器为了实现virtual功能还会合成一些其它成员插入到对象中。我们来看看这些成员的布局。</p>
<h3 id="C-标准的规定"><a href="#C-标准的规定" class="headerlink" title="C++ 标准的规定"></a>C++ 标准的规定</h3><ul>
<li>在同一个Access Section（也就是private,public,protected片段）中，要求较晚出现的数据成员处在较大的内存中。这意味着同一个片段中的数据成员并不需要紧密相连，编译器所做的成员对齐就是一个例子。</li>
<li>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。</li>
<li>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</li>
<li>对于虚基类成员也是同样的未予规定。</li>
</ul>
<h3 id="一般的编译器怎么做？"><a href="#一般的编译器怎么做？" class="headerlink" title="一般的编译器怎么做？"></a>一般的编译器怎么做？</h3><ul>
<li>同一个Access Section中的数据成员按期声明顺序，依次排列。</li>
<li>但成员与成员之间因为内存对齐的原因可能存在空当。</li>
<li>多个Access Section按其声明顺序排放。</li>
<li>基类的数据成员总放在自己的数据成员之前，但虚基类除外。</li>
</ul>
<h3 id="编译器合成的成员放在哪？"><a href="#编译器合成的成员放在哪？" class="headerlink" title="编译器合成的成员放在哪？"></a>编译器合成的成员放在哪？</h3><p>为了实现虚函数和虚拟继承两个功能，编译器一般会合成Vptr和Vbptr两个指针。那么这两个指针应该放在什么位置？C++标准肯定是不曾规定的，因为它甚至并没有规定如何来实现这两个功能，因此就语言层面来看是不存在这两个指针的。</p>
<p>对于Vptr来说有的编译器将它放在末尾，如Lippman领导开发的Cfront。有的则将其放在最前面，如MS的VC，但似乎没人将它放在中间。为什么不放在中间？没有理由可以让人这么做，放在末尾，可以保持C++类对C的struct的良好兼容性，放在最前可以给多重继承下的指针或引用调用虚函数带来好处。</p>
<p>看一小段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">public:</div><div class="line">    int a;</div><div class="line">    virtual void vfc()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    using namespace std;</div><div class="line">    X x;</div><div class="line">    cout&lt;&lt;&amp;x.a&lt;&lt;&quot; &quot;&lt;&lt;&amp;x&lt;&lt;endl;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在VS2010和VC6.0中运行的结果都是地址值&amp;x.a比&amp;x大4，可见说vc的vptr放在对象的最前面此言非虚。</p>
<p>对于Vbptr来说，有好几种方法，在这儿我们只看看VC的实现原理：</p>
<p>对于由虚拟继承而得的类，VC会在其每一个对象中插入一个Vbptr,这个Vbptr指向vitual base class table（我称之为虚基类表）。虚基类表中则存放有其虚基类子对象相对于虚基类指针的偏移量。例如声明如class Y:virtual public X的类的virtual base class table的虚基类表中当存储有X对象相对于Vbptr的偏移量。</p>
<p>对象成员或基类对象成员后面的填充空白不能为其它成员所用</p>
<p>看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">public:</div><div class="line">    int x;</div><div class="line">    char c;</div><div class="line">&#125;;</div><div class="line">class X2:public X</div><div class="line">&#123;</div><div class="line">public:char  c2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X2 x2;</div><div class="line">X x;</div><div class="line">x2=x;</div></pre></td></tr></table></figure>
<p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p>
<p>Vptr与Vbptr^注1</p>
<ul>
<li>在多继承情况下，即使是多虚拟继承，继承而得的类只需维护一个Vbptr；而多继承情况下Vptr则可能有要维护多个Vptr，视其基类有几个有虚函数。</li>
<li>一条继承线路只有一个Vptr，但可能有多个Vbptr，视有几次虚拟继承而定。换言之，对于一个继承类对象来说，不需要新合成vptr，而是使用其基类子对象的vptr。而对于一个虚拟继承类来说，必须新合成一个自己的Vbptr。<br>如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class X&#123;</div><div class="line">    virtual void vf()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">class X2:virtual public X</div><div class="line">&#123;</div><div class="line">    virtual void vf()&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">class X3:virtual public  X2</div><div class="line">&#123;</div><div class="line">     virtual void vf()&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>X3将包含有一个Vptr，两个Vbptr。确切的说这两个Vbptr一个属于X3，一个属于X3的子对象X2,X3通过其Vbptr找到子对象X2，而X2通过其Vbptr找到X。</p>
<p>其中差别在于vptr通过一个虚函数表可以确切地知道要调用的函数，而Vbptr通过虚基类表只能够知道其虚基类子对象的偏移量。这两条规则是由虚函数与虚拟继承的实现方式，以及受它们的存取方式和复制控制的要求决定的。</p>
<h3 id="数据成员的存取"><a href="#数据成员的存取" class="headerlink" title="数据成员的存取"></a>数据成员的存取</h3><p>静态数据成员相当于一个仅对该类可见的全局变量，因为程序中只存在一个静态数据成员的实例，所以其地址在编译时就已经被决定。不论如何静态数据成员的存取不会带来任何额外负担。</p>
<p>非静态数据成员的存取，相当于对象起始地址加上偏移量。效率上与C struct成员的效率等同。因为它的偏移量在编译阶段已经确定。但有一种情况例外：pt-&gt;x=0.0。当通过指针或引用来存取——x而x又是虚基类的成员的时候。因为必须要等到执行期才能知道pt指向的确切类型，所以必须通过一个间接导引才能完成。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在VC中数据成员的布局顺序为：</p>
<ul>
<li>vptr部分（如果基类有，则继承基类的）</li>
<li>vbptr （如果需要）</li>
<li>基类成员（按声明顺序）</li>
<li>自身数据成员</li>
<li>虚基类数据成员（按声明顺序）</li>
</ul>
<h3 id="参考：《深度探索C-对象模型》"><a href="#参考：《深度探索C-对象模型》" class="headerlink" title="参考：《深度探索C++对象模型》"></a>参考：《深度探索C++对象模型》</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/02/05/构造函数语义学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/02/05/构造函数语义学/" itemprop="url">构造函数语义学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-05T23:27:07+08:00">
                2015-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-构造函数"><a href="#C-构造函数" class="headerlink" title="C++构造函数"></a>C++构造函数</h2><p>通常很多C++程序员存在两种误解：</p>
<ul>
<li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li>
<li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li>
</ul>
<p>在读《深度探索C++对象模型》之前，我一直停留在上述二种误解上，所幸的是<br>Lippman为我破除了。下面的部分我将随《深度探索C++对象模型》对C++默<br>认构造函数一探究竟。</p>
<p>C++标准规定：如果类的设计者并未为类定义任何构造函数，那么会有一个默认<br>构造函数被暗中生成，而这个暗中生成的默认构造函数通常是不做什么事的(无<br>用的)，下面四种情况除外。</p>
<p>换句话说，<code>有以下四种情况编译器必须为未声明构造函数的类生成一个会做点事
的默认构造函数</code>。我们会看到这些默认构造函数仅“忠于编译器”，而可能不会按<br>照程序员的意愿程效命。</p>
<h3 id="包含有带默认构造函数的对象成员的类"><a href="#包含有带默认构造函数的对象成员的类" class="headerlink" title="包含有带默认构造函数的对象成员的类"></a>包含有带默认构造函数的对象成员的类</h3><p>若一个类X没有定义任何构造函数，但却包含一个或以上定义有默认构造函数的对象成员，此时编译器会为X合成默认构造函数，该默认函数会调用对象成员的默认构造函数为之初始化。如果对象的成员没有定义默认构造函数，那么编译器合成的默认构造函数将不会为之提供初始化。例如类A包含两个数据成员对象，分别为：string str和char <em>Cstr，那么编译器生成的默认构造函数将只提<br>供对string类型成员的初始化，而不会提供对char</em>类型的初始化。</p>
<p>假如类X的设计者为X定义了默认的构造函数来完成对str的初始化，形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A::A()&#123;Cstr=”hello”&#125;</div></pre></td></tr></table></figure></p>
<p>因为默认构造函数已经定义，编译器将不能再生成一个默认构造函数。但是编译器将会扩充程序员定义的默认构造函数——在最前面插入对初始化str的代码。若有多个定义有默认构造函数的成员对象，那么这些成员对象的默认构造函数的调用将依据<code>声明顺序排列</code>。</p>
<h3 id="继承自带有默认构造函数的基类的类"><a href="#继承自带有默认构造函数的基类的类" class="headerlink" title="继承自带有默认构造函数的基类的类"></a>继承自带有默认构造函数的基类的类</h3><p>如果一个没有定义任何构造函数的类派生自带有默认构造函数的基类，那么编译器为它定义的默认构造函数，将按照声明顺序为之依次调用其基类的默认构造函数。若该类没有定义默认构造函数而定义了<code>多个其他构造函数</code>，那么编译器<code>扩充它的所有构造函数</code>——加入必要的基类默认构造函数。另外，编译器会将基类的默认构造函数代码加在对象成员的默认构造函数代码之前。</p>
<h3 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h3><p>带有虚函数的类，与其它类不太一样，因为它多了一个vptr，而vptr的设置是由编译器完成的，因此编译器会为类的<code>每个构造函数添加代码来完成对vptr的初始化</code>。</p>
<h3 id="带有一个虚基类的类"><a href="#带有一个虚基类的类" class="headerlink" title="带有一个虚基类的类"></a>带有一个虚基类的类</h3><p>在这种情况下，编译器要将虚基类在类中的位置准备妥当，提供支持虚基类的机制。也就是说要在所有构造函数中加入实现前述功能的的代码。没有构造函数将合成以完成上述工作。</p>
<p>总结：简单来讲编译器会为构造函数做的一点事就是调用其基类或成员对象的默认构造函数，以及初始化vprt以及准备虚基类的位置。</p>
<p>总的来说，编译器将对构造函数动这些手脚：</p>
<pre><code>- 如果类虚继承自基类，编译器将在所有构造函数中插入准备虚基类位置的代码和提供支持虚基类机制的代码。
- 如果类声明有虚函数，那么编译器将为之生成虚函数表以存储虚函数地址，并将虚函数指针（vptr）的初始化代码插入到类的所有构造函数中。
- 如果类的父类有默认构造函数，编译将会对所有的默认构造函数插入调用其父类必要的默认构造函数。必要是指设计者没有显示初始化其父类，调用顺序，依照其继承时声明顺序。
- 如果类包含带有默认构造函数的对象成员，那么编译器将会为所有的构造函数插入对这些对象成员的默认构造函数进行必要的调用代码，所谓必要是指类设计者设计的构造函数没有对对象成员进行显式初始化。成员对象默认构造函数的调用顺序，依照其声明顺序。
- 若类没有定义任何构造函数，编译器会为其合成默认构造函数，再执行上述四点。
</code></pre><p>需要说明的是，从概念来上来讲，每一个没有定义构造函数的类都会由编译器来合成一个默认构造函数，以使得可以定义一个该类的对象，但是默认构造函数是否真的会被合成，将视是否有需要而定。C++ standard 将合成的默认构造函数分为 trivial 和 notrivial 两种，前文所述的四种情况对应于notrivial默认构造函数，其它情况都属于trivial。对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p>
<h2 id="拷贝构造函数（copy-constuctor）"><a href="#拷贝构造函数（copy-constuctor）" class="headerlink" title="拷贝构造函数（copy constuctor）"></a>拷贝构造函数（copy constuctor）</h2><p>通常C++初级程序员会认为当一个类为没有定义拷贝构造函数的时候，编译器会为其合成一个，答案是否定的。<code>编译器只有在必要的时候在合成拷贝构造函数</code>。<br>那么编译器什么时候合成，什么时候不合成，合成的拷贝构造函数在不同情况下分别如何工作呢？这是本文的重点。</p>
<h3 id="拷贝构造函数的定义"><a href="#拷贝构造函数的定义" class="headerlink" title="拷贝构造函数的定义"></a>拷贝构造函数的定义</h3><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X::X( const X&amp; x);</div><div class="line">Y::Y( const Y&amp; y, int =0 );</div><div class="line">//可以是多参数形式，但其第二个即后继参数都有一个默认值拷贝构造函数的应用</div></pre></td></tr></table></figure>
<p>当一个类对象以另一个同类实体作为初值时，大部分情况下会调用拷贝构造函数。一般是这三种具体情况：</p>
<ul>
<li>显式地以一个类对象作为另一个类对象的初值，形如X xx=x;</li>
<li>当类对象被作为参数交给函数时。</li>
<li>当函数返回一个类对象时。<br>后两种情形会产生一个临时对象。</li>
</ul>
<h3 id="编译器何时合成拷贝构造函数"><a href="#编译器何时合成拷贝构造函数" class="headerlink" title="编译器何时合成拷贝构造函数"></a>编译器何时合成拷贝构造函数</h3><p>并不是所有未定义有拷贝构造函数的类编译器都会为其合成拷贝构造函数，编译器<code>只有在必要的时候才会为其合成拷贝构造函数</code>。所谓必要的时刻是指编译器在普通手段无法完成解决“当一个类对象以另一个同类实体作为初值”时，才会合成拷贝构造函数。也就是说，当常规武器能解决问题的时候，就没必要动用非常规武器。</p>
<p>如果一个类<code>没有定义拷贝构造函数</code>，通常按照<code>“成员逐一初始化(DefaultMemberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”</code>——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default MemberwiseInitialization)”的手法。</p>
<p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）[^注1]。也就是说在能使用这种常规方式来解决“一个类对象以另一个同类实体作为初值”的时候，编译器是不需要合成拷贝构造函数的。但有些时候常规武器不那么管用，我们就得祭出非常规武器了——拷贝构造函数。有以下几种情况之一，位逐次拷贝将不能胜任或者不适合来完成“一个类对象以另一个同类实体作为初值”的工作。此时，如果类没有定义拷贝构造函数，那么编译器将必须<code>为类合成一个拷贝构造函数</code>。</p>
<ul>
<li>当类内含一个成员对象，而后者的类声明有一个拷贝构造函数时（不论是设计者定义的还是编译器合成的）。</li>
<li>当类继承自一个声明有拷贝构造函数的类时（同样，不论这个拷贝构造函数是被显示声明还是由编译器合成的）。</li>
<li>类中声明有虚函数。</li>
<li>当类的派生串链中包含有一个或多个虚基类。</li>
</ul>
<p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p>
<p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p>
<p>对于继承串链中有虚基类的情况，问题同样出现在继承类向基类提供初值的情况，此时位逐次拷贝有可能破坏对象中虚基类子对象的位置。</p>
<h2 id="命名返回值优化和成员初始化队列"><a href="#命名返回值优化和成员初始化队列" class="headerlink" title="命名返回值优化和成员初始化队列"></a>命名返回值优化和成员初始化队列</h2><h3 id="命名返回值优化"><a href="#命名返回值优化" class="headerlink" title="命名返回值优化"></a>命名返回值优化</h3><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p>
<p>foo()的原型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">X foo() </div><div class="line">&#123; </div><div class="line">    X xx; </div><div class="line">    if(...) </div><div class="line">        return xx; </div><div class="line">    else </div><div class="line">        return xx; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化后的foo()以result取代xx：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void  foo(X &amp;result)</div><div class="line">&#123;</div><div class="line">    result.X::X();</div><div class="line">    if(...)</div><div class="line">    &#123;</div><div class="line">        //直接处理result</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        //直接处理result</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>
<p>注：Lippman在《深度探索C++》书中指出NRV的开启与关闭取决于是否有显式定义一个拷贝构造函数，我实在想不出有什么理由必须要有显示拷贝构造函数才能开启NRV优化，于是在vs2010中进行了测试，测试结果表明，在release版本中，不论是否定义了一个显式拷贝构造函数，NRV都会开启。由此可见vs2010并不以是否有一个显式拷贝构造函数来决定NRV优化的开启与否。但同时，立足于这一点，可以得出Lippman所说的以是否有一个显式定义的拷贝构造函数来决定是否<br>开启NRV优化，应该指的是他自己领导实现的cfront编译器，而非泛指所有编译器。那么cfront又为什么要以是否定义有显示的拷贝构造函数来决定是否开启NRV优化呢？我猜测，他大概这样以为，当显式定义有拷贝构造函数的时候一般代表着要进行深拷贝，也就是说此时的拷贝构造函数将费时较长，在这样的情况下NRV优化才会有明显的效果。反之，不开启NRV优化也不是什么大的效率损失。</p>
<p>另外，有一点要注意的是，NRV优化，有可能带来程序员并不想要的结果，最明显的一个就是——当你的类依赖于构造函数或拷贝构造函数，甚至析构函数的调用次数的时候，想想那会发生什么。由此可见、Lippman的cfront对NRV优化抱有更谨慎的态度，而MS显然是更大胆。</p>
<h3 id="成员初始化队列（Member-Initialization-List）"><a href="#成员初始化队列（Member-Initialization-List）" class="headerlink" title="成员初始化队列（Member Initialization List）"></a>成员初始化队列（Member Initialization List）</h3><p>对于初始化队列，我相信厘清一个概念是非常重要的：在构造函数中对于对象成员的初始化发生在初始化队列中——或者我们可以把初始化队列直接看做是对成员的定义，而构造函数体中进行的则是赋值操作。所以不难理解有四种情况<br>必须用到初始化列表：</p>
<ul>
<li>有const成员</li>
<li>有引用类型成员</li>
<li>成员对象没有默认构造函数</li>
<li>基类对象没有默认构造函数</li>
</ul>
<p>前两者因为要求定义时初始化，所以必须明确的在初始化队列中给它们提供初值。后两者因为不提供默认构造函数，所有必须显示的调用它们的带参构造函数来定义即初始化它们。</p>
<p>显而易见的是当类中含有对象成员或者继承自基类的时候，在初始化队列中初始化成员对象和基类子对象会在效率上得到提升——省去了一些赋值操作嘛。</p>
<p>最后，一个关于初始化队列众所周知的陷阱，初始化队列的顺序，请参考《C++primer》或者《深度探索C++对象模型》。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg"
               alt="suyuan" />
          <p class="site-author-name" itemprop="name">suyuan</p>
           
              <p class="site-description motion-element" itemprop="description">东京下雨，淋湿巴黎</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suyuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
