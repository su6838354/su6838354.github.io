<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="东京下雨，淋湿巴黎">
<meta property="og:type" content="website">
<meta property="og:title" content="苏远的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="苏远的博客">
<meta property="og:description" content="东京下雨，淋湿巴黎">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏远的博客">
<meta name="twitter:description" content="东京下雨，淋湿巴黎">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>苏远的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e56d57ba89bb058da8fdd8841e98770f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏远的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/19/huwai-1511105901710/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/19/huwai-1511105901710/" itemprop="url">户外项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T23:38:21+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/个人项目/" itemprop="url" rel="index">
                    <span itemprop="name">个人项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一套面向户外俱乐部和户外爱好者的 活动展示，报名，分享游记的管理工具</p>
<ul>
<li><p>预览<br><a href="http://hw.suleyan.com/user-hw" target="_blank" rel="external">手机用户页面</a> 建议手机查看<br><a href="http://hw.suleyan.com/" target="_blank" rel="external">pc管理后台</a> 账户: admin 123456</p>
<p>  香港服务器，带宽又有限，访问可能有点慢</p>
</li>
<li><p>代码地址<br><a href="git@github.com:sfm-rc/koa2-hw.git">后端 nodejs</a><br><a href="git@github.com:sfm-rc/hw-admin.git">管理后台前端 react</a><br><a href="git@github.com:sfm-rc/hw.git">用户侧前端 react</a></p>
</li>
</ul>
<h1 id="主要技术栈"><a href="#主要技术栈" class="headerlink" title="主要技术栈"></a>主要技术栈</h1><p>webpack<br>react<br>redux<br>koa2<br>antd<br>antd-mobile<br>atool<br>dora<br>pm2<br>mysql<br>docker</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>可以把整套服务起在docker中，下面没有涉及mysql，可以通过–link mysql_server单独到一个mysql docker容器；<br>在docker中取下三份代码；</p>
<ul>
<li><p>koa2 唯一需要起到服务代码<br>提供服务接口和手机页面静态资源服务</p>
<pre><code>npm install &amp;&amp; npm run compile    
pm2 start pm2.json
</code></pre></li>
<li><p>hw 中<br>提供手机页面静态资源</p>
<pre><code>npm install &amp;&amp; npm run build:prod    
cp dist ../koa2-hw/public
</code></pre></li>
<li><p>hw-admin<br>提供pc管理后台静态资源</p>
<pre><code>npm install &amp;&amp; npm run build
</code></pre></li>
<li><p>nginx<br>提供手机页面和管理后台入口</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">nginx 中配置</div><div class="line">upstream hwserver &#123;</div><div class="line"> server 127.0.0.1:3001;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line">    #access_log  /var/log/nginx/host.access.log  main;</div><div class="line"></div><div class="line">#    location / &#123;</div><div class="line">#        root   /usr/share/nginx/html;</div><div class="line">#        index  index.html index.htm;</div><div class="line">#    &#125;</div><div class="line"></div><div class="line"></div><div class="line">        root /usr/webapp/hw-admin/dist;</div><div class="line"></div><div class="line">        location /user-hw &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /user-hw-static &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /hw &#123;</div><div class="line">                proxy_pass http://hwserver;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location /admin-hw &#123;</div><div class="line">                root /user/webapp/hw-admin/dist;</div><div class="line">                rewrite &apos;^/admin-hw/(.*)&apos; /$1;</div><div class="line">#               try_files $uri /index.html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">                #proxy_pass http://hwserver;</div><div class="line">                #rewrite ^(.*)$ index.html</div><div class="line">        #       root /user/webapp/hw-admin/dist;</div><div class="line">                try_files $uri /index.html;</div><div class="line">        &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/基于create-react-app-快速搭建react项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/基于create-react-app-快速搭建react项目/" itemprop="url">基于create-react-app快速搭建react项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T18:28:31+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>本身安装了nodejs，npm或者yarn</p>
<pre><code>yarn global add create-react-app
</code></pre><p>或者</p>
<pre><code>npm install -g create-react-app
</code></pre><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><pre><code>create-react-app react-demo
</code></pre><p><img src="/images/1504432144489.png" alt="image"></p>
<p><img src="/images/1504432202611.png" alt="image"></p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>查看scripts 中可以执行等命令</p>
<pre><code>npm run-script
</code></pre><p><img src="/images/1504432536022.png" alt="image"></p>
<p>我们可以猜想npm start 是开发模式下，启动服务热加载编译；npm run build 自然是编译程序</p>
<p>执行</p>
<pre><code>npm start 
</code></pre><p>会发现自动打开了浏览器<a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a> 属于你等react web 已经出现了<br>可以打开App.js编写代码；<br>另外该开发套件本身没有包含react-router，你需要自己引入</p>
<pre><code>yarn add react-router
yarn add react-router-dom
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><a href="https://github.com/su6838354/react-demo" target="_blank" rel="external">https://github.com/su6838354/react-demo</a></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这时候整个react项目已经搭建好了，不需要知道任何的webpack等工程化技术，在node_modules/react-scripts 目录下我们可以发现该开发套件的真谛。<br><img src="/images/1504432860140.png" alt="image"></p>
<blockquote>
<p>bin     执行react-scripts 命令的入口<br>config 根据环境变量和设置，webpack/环境/jest/polyfill等一些配置<br>scripts 各种脚本，编译,测试，初始化，开发等，为package.json中定义的scripts和最初创建项目的命令服务<br>temple 最初创建项目等时候 采用这套模版生成我们最初的项目</p>
</blockquote>
<p>在未来项目配置不符合你等需求等时候，可以查看 <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md</a><br>修改配置以满足需求；</p>
<p>比如 需要修改引入等js，css等相对路径，修改下自己等环境变量即可<br>export PUBLIC_URL=’/home/static/‘，当然还有其他方式比如修改package.json的homepage<br>参考<br><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-assets-outside-of-the-module-system" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-assets-outside-of-the-module-system</a></p>
<p><img src="/images/1504434422598.png" alt="image"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">https://github.com/facebookincubator/create-react-app</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/XSS和CSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/XSS和CSRF/" itemprop="url">XSS 和CSRF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T20:30:39+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="XSS：跨站脚本（Cross-site-scripting）"><a href="#XSS：跨站脚本（Cross-site-scripting）" class="headerlink" title="XSS：跨站脚本（Cross-site scripting）"></a>XSS：跨站脚本（Cross-site scripting）</h1><ul>
<li><p>示例<br>比如 别人在论坛中提交了一段代码<br><code>while(true){
  alert(&#39;1&#39;)
}</code><br>当自己打开这个论坛的时候，就会一直执行这段js，这段js可以用来盗号或者执行未授权的操作</p>
</li>
<li><p>原理<br>XSS 其实就是所谓的 HTML 注入，攻击者的输入没有经过后台的过滤直接进入到数据库，最终显示给来访的用户。如果攻击者输入一段 js 脚本，就能窃取来访者的敏感信息（比如 Cookie），实现伪装成来访者对网站发送危险请求。</p>
</li>
<li><p>防御<br>避免 XSS 的方法之一主要是对用户输入的内容进行过滤，比如 PHP 里面的 htmlspecialchars() 函数。</p>
</li>
</ul>
<h1 id="CSRF（Cross-site-request-forgery）跨站请求伪造，又叫XSRF"><a href="#CSRF（Cross-site-request-forgery）跨站请求伪造，又叫XSRF" class="headerlink" title="CSRF（Cross-site request forgery）跨站请求伪造，又叫XSRF"></a>CSRF（Cross-site request forgery）跨站请求伪造，又叫XSRF</h1><blockquote>
<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>
</blockquote>
<ul>
<li><p>原理:<br>要完成一次CSRF攻击，受害者必须依次完成以下步骤：</p>
<ul>
<li>登录受信任网站A，并在本地生成Cookie。</li>
<li>在不登出A的情况下，访问危险网站B。危险网站B，它里面有一段HTML的代码如下：　　<br><code>&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</code></li>
<li>你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块！</li>
</ul>
</li>
<li><p>防御<br>CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！<br>通过下面途径可以防御：</p>
<ul>
<li>敏感动作使用post，不要用get，post 受到跨域限制，浏览器在发送post请求前，发送option 询问服务端是否允许该源（域名+端口）的访问，假如自己站点存在让黑客发送危险请求的 漏洞，该方法就没用了。</li>
<li>给每个表单加入随机 Token 进行验证，这样B页面无法获取A页面的 Token 导致请求验证失败，从而防止了 CSRF。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/浪潮之巅/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/浪潮之巅/" itemprop="url">浪潮之巅</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T22:07:05+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读/" itemprop="url" rel="index">
                    <span itemprop="name">阅读</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AT&amp;T、IBM、微软、苹果、google等IT公司的发展历史，揭示科技工业的胜败规律，说明这些公司是如何在每一次科技革命浪潮到来时站在浪尖，实现跨越式发展的。</p>
<p>（2017-11-25日更新）</p>
<h3 id="阿里和腾讯"><a href="#阿里和腾讯" class="headerlink" title="阿里和腾讯"></a>阿里和腾讯</h3><p>阿里、腾讯、百度的崛起，头条、美团、滴滴的紧随其上，为国内的互联网氛围增加了更浓烈的火药味，谁会持续站在浪潮之巅。</p>
<p>都说科技改变生活，腾讯和阿里在生活中无处不在，但是最新的赛季到底谁是最强王者，是腾讯爸爸，还是阿里爸爸？还是说最后会半路杀出个程咬金？<br><img src="/images/book/b_5.jpg" alt=""><br><img src="/images/book/b_6.jpg" alt=""><br><img src="/images/book/b_7.jpg" alt=""><br><img src="/images/book/b_8.jpg" alt=""></p>
<h3 id="我消灭你，与你无关-打败你的不一定是对手而是一个过路人"><a href="#我消灭你，与你无关-打败你的不一定是对手而是一个过路人" class="headerlink" title="我消灭你，与你无关 打败你的不一定是对手而是一个过路人"></a>我消灭你，与你无关 打败你的不一定是对手而是一个过路人</h3><p>这是一个摧毁你，却与你无关的时代；这是一个跨界打劫你，你却无力反击的时代；这是一个你醒来太慢，干脆就不用醒来的时代；这是一个不是对手比你强，而是你根本连对手是谁都不知道的时代！</p>
<p>最近，尼康退出中国，裁员两千人！</p>
<p><img src="/images/book/b_1.jpeg" alt=""></p>
<p>很多人以为尼康是被同行打败，没想到居然是毫无相关的行业。尼康直接宣布破产的真相：受智能手机普及的影响！<br>中国有一部很牛的科幻小说，名字叫做《三体》。里面有句话，叫做：“我消灭你，与你无关。”<br>这句话真够嚣张跋扈，但却充满大智慧，说明了大趋势，揭示了整个人类世界前进和发展的基本规律。<br>比如，今年康师傅和统一方便面的销量急剧下滑，不过它们的对手真不是白象、今麦郎，而是美团、饿了么等外卖。<br>比如，打败口香糖不是益达，而是微信、王者荣耀。在超市收银台这个消费场景，过去顾客在排队缴费的时候无聊就往购物篮里拿上两盒口香糖，而今天大家都在看微信、刷朋友圈、玩王者。<br>比如，共享单车，一块钱，随便骑，骑到任何地方，停下，锁车就走，不用管。这个东西一出来，黑车司机哭了。卖单车的店铺、修自行车的小摊子，生意都一落千丈，关门是迟早的事情。<br>怎么样，大趋势是很残酷的，它杀人是不眨眼，也不会流血的，根本不见红。<br>说声对不起？不好意思，不关我的事，我根本没关注到你，只是一个不小心，让你倒霉了。这就叫：我消灭你，但与你无关。</p>
<p>结语：<br>在这个跨界打劫、飞速变化的时代，你永远也无法想象下个竞争对手，你也很难猜到新兴的什么行业就打败了传统的什么行业。<br>我们唯一能做的，就是保持一个足够开阔的视野，每当有新鲜事物发生、新兴行业的兴起的时候，多去发散思考一下，说不定想到的某些点，就串联成线，就可以比别人早一点看到未来，早一点抓住机遇呢。<br>你不自我革新，不自我变革，就只能等着别人来革你的命！<br>既然“羊毛出在狗身上，由猪买单”，同样““我消灭你，与你无关。”！这是今天的状况！</p>
<h3 id="AT-amp-T拥有垄断资源的百年公司，为何最后走向衰落？"><a href="#AT-amp-T拥有垄断资源的百年公司，为何最后走向衰落？" class="headerlink" title="AT&amp;T拥有垄断资源的百年公司，为何最后走向衰落？"></a>AT&amp;T拥有垄断资源的百年公司，为何最后走向衰落？</h3><ul>
<li><p>前身是贝尔电话公司。屡次遭反垄断法的切割和约束，却没有倒下，反而因此修枝剪叶，发展得更好。</p>
<blockquote>
<p>反垄断法逼着公司进行科技进步，而不能利用垄断优势坐享其成。后者往往令公司失去技术领先地位。</p>
</blockquote>
</li>
<li><p>终结AT&amp;T的内因是贪婪和短视，为了股东利益最大化，在无线通讯和互联网技术革命来临的关键时刻，将公司业务分拆成小公司上市，卖股票挣钱，杀鸡取卵，最终被下一波浪潮吞没，错失发展机会。</p>
<blockquote>
<p>当一家公司没有人对它有控制权时，它的长期发展就会有问题。<br>1995年，美国股票开始疯涨，AT&amp;T的股票大部分被华尔街投资银行掌控，这些人只为了自己的股票利益，完全不顾公司的长期发展，因而令公司屡屡做出短视的错误决策。</p>
</blockquote>
</li>
</ul>
<p>在阿里、京东之前，王峻涛和8848才是中国电商对鼻祖，但是失去控制权，又错过了最佳上市时机，导致8848退出了历史对舞台，也让后来对阿里巴巴没有对手。<br><img src="/images/book/b_2.jpeg" alt=""></p>
<h3 id="蓝色巨人IBM——基因决定了IBM不会成为PC大王"><a href="#蓝色巨人IBM——基因决定了IBM不会成为PC大王" class="headerlink" title="蓝色巨人IBM——基因决定了IBM不会成为PC大王"></a>蓝色巨人IBM——基因决定了IBM不会成为PC大王</h3><p><img src="/images/book/b_3.jpeg" alt=""><br>从机械时代的制表机起家，二战时还参加制造勃朗宁自动步枪和M1冲锋枪。</p>
<ul>
<li>第一次转型：从机械制造到计算机制造：领导电子技术革命潮流（1950S-1970S）<br>第二次世界大战是机械时代和电子时代的分水岭，1952年小沃森出任IBMCEO，领导电子技术革命的浪潮。其最大贡献是将计算机从高政府部门和军方推广到民间，将它的功能由科学计算变成商用。</li>
<li>错过全球信息化的大潮（1980S）<br>1976年，乔布斯发明第一台可商业化的个人电脑Apple-Ⅰ。随后IBM决定也要加快研制自己的PC，最终推出IBM-PC（1981），占领了大部分的微机市场。但是IBM最后并没有成为PC大王，而是推出了PC市场，原因有三：IBM的固有基因、反垄断后遗症、微软的出现。<ul>
<li>IBM的基因：锁定政府部门和企业单位为其主要客户，不屑于大众销售（效益太低）</li>
<li>1970-1980年IBM与司法部打了10年反垄断官司，最终和解结果是IBM必须公开一些技术，允许其他厂商制造兼容机，于是IBM就失去了优势，成为众多PC制造商之一。</li>
</ul>
</li>
<li>比尔盖茨凭操作系统摆了IBM一道：盖茨先空手套白狼，买了别人的DOS然后转卖IBM，他没有让IBM买断而是每台PC收不多的版权费，结果反而积少成多。他又利用合同漏洞再卖给别人，IBM却告不赢他。PC谁都可以做，操作系统用惯了却不能换，微软凭Windows系统确定了自己的垄断地位。<br>就这样，IBM成了80年代信息革命中的落伍者IBM出现了严重亏损，开始大幅裁员。</li>
<li>第二次转型：从计算制造到服务（1990S）<br>1993年，郭士纳出任IBMCEO，顺利把IBM从一个计算机硬件制造商公司转变为一个以服务和软件为核心的服务性公司。开始大力推广廉价开源的linux服务器。</li>
<li>IBM走了与AT&amp;T截然不同的路，AT&amp;T将一个好好的公司拆散卖掉，IBM将分出去的公司整合回来，打造了一个从硬件到软件到服务一条龙的航空母舰。现在，其开源服务器Linux仍然牢牢控制美国政府部门、军队、大公司和银行的业务。</li>
<li>IBM是一家保守的公司。他的创新能力很强，但很少花大力气去用新技术开拓新市场，因为政府、大企业更注重稳定性，不能接受一点错误。</li>
<li>2004年IBM将其PC业务（包括Thinkpad品牌）卖给联想，IBM去掉了亏损的部门，降低了成本，提高了盈利能力。联想也得到了Thinkpad这个第一品牌，提高了市场份额，也比大手大脚惯了的IBM更有能力降低笔记本部门的成本（人工便宜），因此这次买卖对联想IBM各有好处。</li>
</ul>
<h3 id="Apple——苹果公司和乔布斯神话"><a href="#Apple——苹果公司和乔布斯神话" class="headerlink" title="Apple——苹果公司和乔布斯神话"></a>Apple——苹果公司和乔布斯神话</h3><ul>
<li>1976 苹果计算机公司成立</li>
<li>1977乔布斯发明第一台可商业化的个人电脑Apple-Ⅰ</li>
<li>1984 推出采用图像视窗界面操作系统的麦金托什电脑（Macintosh）</li>
<li>1985 乔布斯和自己请来的CEO斯卡利（原百事可乐CEO）权力斗争，被踢出自己创办的公司</li>
<li>1986乔布斯收购了皮克斯（Pixar）动画工作室。推出玩具总动员，大受欢迎</li>
<li>1994 苹果告微软视窗系统抄袭它的麦金托什操作系统，官司最终和解。（其实大家都是抄施乐公司的）</li>
<li>1997 乔布斯重返苹果，任命为临时CEO。着手解决亏损的公司。</li>
<li>1998 推出iMac，苹果重新盈利</li>
<li>2001 推出ipod，颠覆了音乐产业</li>
<li>2007 推出iphone，颠覆了珍格格手机产业</li>
<li>2010 推出ipad，同年苹果公司的市值再次超过微软，成为全球最值钱的IT公司。</li>
<li>iphone 虽然打败了诺基亚，但是三星、华为、小米的崛起也让app感到了恐慌<br><img src="/images/book/b_4.jpg" alt=""></li>
</ul>
<h3 id="计算机工业生态三大规律"><a href="#计算机工业生态三大规律" class="headerlink" title="计算机工业生态三大规律"></a>计算机工业生态三大规律</h3><ul>
<li>摩尔定律（Moore’s law）：集成电路的集成度每两年会翻一番。<br>后来大家把周期缩短到18个月。现在，计算机等IT产品性能每18个月就翻一番。</li>
<li>安迪-比尔定律（Andy and Bill’s Law）<br>比尔（比尔盖茨）要拿走安迪（原英特尔CEO）所给的。即，每当以英特尔为首的硬件商提高了电脑性能，微软为首的软件商就会吃掉性能增加的大部分。反过来，只要微软不断推出更高级的操作系统，用户就不得不升级硬件更新，英特尔等硬件商就能生产更高级的芯片、硬盘挣钱。<br>该定律把原本属于耐用消费品的电脑手机变作消耗品，刺激整个IT行业的发展。<br>人们把微软和英特尔领导的PC时代称为WinTel体系。</li>
<li>反摩尔定律<br>一个IT公司如果今天和18个月钱卖掉同样多的、同样的产品，它的营业额就要降一半。<br>该定律刺激IT公司不断寻找技术突破，提高性能，同时也为新兴小公司提高超越大公司的机会。</li>
</ul>
<h3 id="英特尔"><a href="#英特尔" class="headerlink" title="英特尔"></a>英特尔</h3><p>微机时代的领导者只有两个，软件方面的微软和硬件方面的英特尔。</p>
<h3 id="微软——IT领域的罗马帝国"><a href="#微软——IT领域的罗马帝国" class="headerlink" title="微软——IT领域的罗马帝国"></a>微软——IT领域的罗马帝国</h3><ul>
<li>斗败苹果：以开放兼容占据市场<br>微软的崛起起源于乔布斯的一个致命错误：把未公开发布的麦金托什给盖茨看了，盖茨惊讶其图形化操作系统，回去一边拖延时间，一边自己暗暗研究新的操作系统windows。为了完成研发上的布局，盖茨要在市场上尽可能用它落后的DOS坚持到微软视窗系统开发出来，主要有两招做法：<ul>
<li>薄利多销：以每个拷贝5美分近乎免费的价格，把DOS预装在IBM-PC上，保证了大部分销售</li>
<li>来者不拒：同时吸引了大量个人在DOS上开发软件，使用户产生对微软的依赖；</li>
</ul>
</li>
<li>封闭的苹果主要败在微软人民战争的战术上：<br>技术领先的苹果走封闭式道路和纯技术路线，不开放麦金托什的技术，不允许其他厂商制造兼容机，坚持硬件软件一起卖；而IBM已经被迫开放兼容机，于是从上世纪80年代中期起，世界硬件市场的格局从苹果对IBM变成苹果对IBM加上所有兼容机。IBM-PC越做越便宜，市场占有率越来越高。微软则借IBM-PC的流行，以超低价为诱饵绑定操作系统在IBM-PC上，于是自己的市场占有率也不断攀升。另一方面又对第三方软件商以支持与合作的态度鼓励，于是微软的操作系统上积聚了大量廉价实用的软件。而苹果的最大败笔就是兼容性极差。连自己内部不同版本的机器都不兼容。</li>
<li>搞垮网景：靠垄断优势搞捆绑销售<br>上世纪90年代，互联网兴起，网景浏览器先拔头筹，大受欢迎。盖茨立即意识到要守住用户通向网络的大门，火速推出IE，用上杀手锏：与widows捆绑，免费提供给用户。网景就被斗垮了。微软这招百试不爽。当然也受反垄断控告，但微软以捆绑销售是为了防止盗版蒙混过关。</li>
</ul>
<h3 id="思科公司——乘着互联网浪潮起家的企业"><a href="#思科公司——乘着互联网浪潮起家的企业" class="headerlink" title="思科公司——乘着互联网浪潮起家的企业"></a>思科公司——乘着互联网浪潮起家的企业</h3><p>1985年，互联网刚刚冒头，为了把不同协议的局域网连在一起，急需能协调多协议的路由器，思科正好应运而生，1986年就推出多协议路由器，马上占领市场。</p>
<h3 id="雅虎——开创互联网免费模式"><a href="#雅虎——开创互联网免费模式" class="headerlink" title="雅虎——开创互联网免费模式"></a>雅虎——开创互联网免费模式</h3><ul>
<li>在1990s，互联网刚刚兴起，雅虎创始人杨致远和戴维•菲洛在斯坦福大学制作了给网页按主题分类的系统，方便搜索资料，后来越来越多人使用，最终创建公司（1995）。</li>
<li>雅虎对互联网最大的贡献是开创了互联网开放、免费的商业模式——浏览网页、使用搜索、邮箱等服务不收费，网站只把内容做好，致力提高流量，凭此赚取广告费实现盈利。</li>
<li>但是，雅虎的基因骨子里是个媒体公司，不是技术公司，后来他自不量力要与google斗技术，耗费大量资源，最终沦落到现在等待被收购的处境。假如他趁早放弃自己亏损的搜索业务，与google合作，专心做好自己的媒体，应该还能在互联网占有一席之地。</li>
</ul>
<h3 id="惠普——硅谷的见证人"><a href="#惠普——硅谷的见证人" class="headerlink" title="惠普——硅谷的见证人"></a>惠普——硅谷的见证人</h3><ul>
<li>斯坦福工业园最早的入驻者之一，生产电子仪器起家，后来进入计算机市场，发明喷墨打印机。</li>
<li>但由于女CEO菲奥莉娜坚持收购亏损的康柏公司（电脑硬件生产），企图联合其市场占有率挑战戴尔，结果两个问题重重的公司合并后业绩更差。惠普一落千丈。</li>
<li>2005年，赫德接管，开源节流，开创惠普的快速发展期。但后因性骚扰事件离职。</li>
<li>惠普从来没有领导过哪次技术浪潮，业务也越来越向不稳定低利润的消费电子公司而不是创新公司靠拢，因此前景并不很美妙。</li>
</ul>
<h3 id="摩托罗拉——没落的贵族"><a href="#摩托罗拉——没落的贵族" class="headerlink" title="摩托罗拉——没落的贵族"></a>摩托罗拉——没落的贵族</h3><ul>
<li>曾经的无线通信领域的领先者，手机通信的发明者，发明大哥大（模拟手机），技术和品质一直领先。</li>
<li>摩托罗拉在二战后到1990S在模拟手机、计算机处理器、数字处理芯片（DSP）领域上都是大哥大地位，但进入数字移动通信时代后却败给了诺基亚一众非老牌通信厂家；计算机处理器败给了英特尔、DSP败给了德州仪器。</li>
<li>作者认为是摩托罗拉自己的基因决定了这一切。其公司的传统信念过于重视技术，对外观、功能的关注较少，低估了消费者对这方面的重视度。产品的开发周期又太长，最终落伍了。</li>
<li>2000年前后的铱星计划的失败给了摩托罗拉沉重的打击，这个计划的技术无与伦比却超前于市场。</li>
<li>摩托罗拉三个领域同时发展，战线太长，如果专注一个，或许还能在某一领域保持老大地位。</li>
<li>进入智能机时代后，摩托罗拉铁了心把赌注全押在Android上，市场反响不错。</li>
</ul>
<h3 id="一个IT公司创业成功必须具备的条件"><a href="#一个IT公司创业成功必须具备的条件" class="headerlink" title="一个IT公司创业成功必须具备的条件"></a>一个IT公司创业成功必须具备的条件</h3><ul>
<li>比起谋臣，一个有领袖气质的创始人更可能成功</li>
<li>光有好团队和技术不够，还要有商业头脑，还必须找到一个能盈利的商业模型（business model）</li>
<li>要有卓越的判断力和执行力，才能在大风大浪的硅谷生存下去</li>
<li>一个新公司的成功很大程度要看外部环境好不好。</li>
<li>最重要的是，创业者要有好运气。</li>
</ul>
<h3 id="信息产业的规律性："><a href="#信息产业的规律性：" class="headerlink" title="信息产业的规律性："></a>信息产业的规律性：</h3><ul>
<li>70-20-10律：在信息产业的同一领域里，一般容不下三个以上的主要竞争者，老大、老二和老三的市场占有率比例大概是70%比20%，剩下10%由一大群小产家分。</li>
<li>诺威格定律：一家公司的市场占有率超过50%后，就无法再使市场占有率翻番了。所以它必须不断寻找新的成长点，或扩展业务，或彻底转型进入其他行业，但由于企业基因决定定律，转型成功很难。</li>
<li>企业基因决定定律：一个公司创始初期形成的企业文化和商业模式、风格将深刻影响企业的发展。比如苹果至今仍然保持着硬件软件一起卖的相对封闭的商业模式。</li>
</ul>
<h3 id="风险投资和华尔街对科技产业的贡献"><a href="#风险投资和华尔街对科技产业的贡献" class="headerlink" title="风险投资和华尔街对科技产业的贡献"></a>风险投资和华尔街对科技产业的贡献</h3><p>风险投资、天使投资人是科技创业者最坚实的后盾，是幕后的英雄；投资银行和华尔街则是吹鼓手，有利可图时可以捧你，无利可图则可以摔死你。</p>
<h3 id="挑战者Google——技术和商业的完美结合"><a href="#挑战者Google——技术和商业的完美结合" class="headerlink" title="挑战者Google——技术和商业的完美结合"></a>挑战者Google——技术和商业的完美结合</h3><ul>
<li>找到自己企业正确的使命非常重要，这决定着该企业是否可以为大众市场所接受。比如微软的盖茨明确自己的使命是让计算机便宜下来，并且变得好用。他做到了，于是成为微机之王。Google的创始人布林和佩奇很早则明白，在互联网时代，让所有人很容易免费上网并方便地找到自己想要的东西的公司，必将成为互联网之王。（关键词：免费和方便）他们做到了，于是成为了互联网之王。</li>
<li>他们都是面向大众市场，专注于每个人都要使用的服务，于是挣到了最大份额的钱。而面向企业用户的IBM和面向精英的苹果，由于市场的变化和不确定性比较大，企业的抗风险能力自然比不上靠大众市场吃饭的Google和微软，因为不论经济形势好坏大家都要买日用品，都要用PC，都要上网。</li>
<li>Google的Android发展模式是学微软的做法，横着吃整个市场，他只关心最重要的操作系统部分，而把上下游全部交出去。比微软更绝的是，Android是免费的。</li>
</ul>
<h3 id="诺基亚——成功的转基因公司"><a href="#诺基亚——成功的转基因公司" class="headerlink" title="诺基亚——成功的转基因公司"></a>诺基亚——成功的转基因公司</h3><p>诺基亚最初只是芬兰一家木工公司，最后竟成功转型成为世界上最大的手机制造商，原因有三：</p>
<ul>
<li>抓住了移动通信从模拟到数字化的契机<br>80年代，手机通信从第一代模拟时代向数字化时代转变。欧洲抢先制定了新一代移动通信标准GSM，第一个投入商业运行的GSM移动通信电话网络就是芬兰公司运营的，手机的提供商就是诺基亚公司。<br>而美国此时同时出现了多个标准，非常混乱，最终GSM胜出一统天下，美国摩托罗拉也就失去先机。</li>
<li>政府的大力扶植</li>
<li>推翻了在模拟时代摩托罗拉制定的商业竞争规则。<br>摩托罗拉败在没有发现数字时代手机市场的重大变化。当手机竞争从信号处理技术的竞争变成为了产品功能、方便性、新颖性及外观的竞争时，摩托罗拉等公司积累了几十年的经验就变得不那么重要了。</li>
</ul>
<h3 id="印钞机——最佳的商业模式"><a href="#印钞机——最佳的商业模式" class="headerlink" title="印钞机——最佳的商业模式"></a>印钞机——最佳的商业模式</h3><p>最好的商业模式就是印钞机式的，它不需要多少人力，一旦运作起来便能自己产生利润，持续发展。</p>
<ul>
<li>Google的广告系统：<br>传统媒体广告业主要有三项成本：①运营成本，如办报、发行、印刷的成本；②批发或零售费用，包括给广告批发商让利或支付广告销售人员的工资等；③订单处理，支付管理订单和安排广告刊登人员的工资。Google的自动化广告系统成功将后两种成本降到最低，客户自己申请登记，系统自动根据用户搜索内容匹配关键词，显示对应广告，然后自动计算费用。不需要人力管理。</li>
<li>ebay和亚马逊的在线市场<br>网络时代人们有发便地交易旧货的需求，于是ebay出现了，并收购paypal解决了网络支付问题。通过向卖家和买家收取手续费，只要做好平台的维护便可不断收钱。但是很难解决欺诈的问题，于是只向正规商家开放的Amazon出现了。</li>
<li>戴尔的虚拟工厂<br>戴尔的商业模式说白了就是将所有硬件生产外包，自己只负责订单处理和销售，将传统制造业的7个环节（产品设计、原料采购、仓储运输、加工制造、订单处理、批发经营与零售）减少到最后2个，而且采用直销手段，不经过批发零售商，大大降低成本和价格。</li>
</ul>
<h3 id="金融风暴的冲击"><a href="#金融风暴的冲击" class="headerlink" title="金融风暴的冲击"></a>金融风暴的冲击</h3><p>金融风暴就像是一场冰河期，那些常年亏损却因总体经济形势好而不倒闭的大企业就像是恐龙，在冰河时期将被彻底淘汰，那些新兴的小企业就有机会取而代之。这就是商业中的自然代谢。</p>
<h3 id="下一个Google——下一个科技浪潮"><a href="#下一个Google——下一个科技浪潮" class="headerlink" title="下一个Google——下一个科技浪潮"></a>下一个Google——下一个科技浪潮</h3><p>云计算很可能成为下一个科技浪潮，它将使用户摆脱桌面，通过浏览器，借高速网络和云端服务器，随时随地方便地享受各种应用。<br>互联网2.0目前只是互联网1.0的一种进化，仍未找到明确的商业模式，因此前景未明。</p>
<p>参考<a href="https://book.douban.com/review/5149990/" target="_blank" rel="external">网络文章</a>，加了些自己读后对理解</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/15/shared-ptr线程安全性分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/15/shared-ptr线程安全性分析/" itemprop="url">shared_ptr线程安全性分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-15T01:49:52+08:00">
                2015-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="shared-ptr的线程安全性"><a href="#shared-ptr的线程安全性" class="headerlink" title="shared_ptr的线程安全性"></a>shared_ptr的线程安全性</h3><p>boost官方文档对shared_ptr线程安全性的正式表述是：shared_ptr对象提供与内置类型相同级别的线程安全性。【shared_ptrobjects offer the same level of thread safety as built-in types.】具体是以下三点。</p>
<pre><code>- 同一个shared_ptr对象可以被多线程同时读取。【A shared_ptrinstance can be &quot;read&quot; (accessed using only const operations)simultaneously by multiple threads.】
- 不同的shared_ptr对象可以被多线程同时修改（即使这些shared_ptr对象管理着同一个对象的指针）。【Different shared_ptr instances can be &quot;written to&quot;(accessed using mutable operations such as operator= or reset) simultaneouslyby multiple threads (even when these instances are copies, and share the samereference count underneath.) 】
- 任何其他并发访问的结果都是无定义的。【Any other simultaneous accesses result in undefined behavior.】
</code></pre><p>第一种情况是对对象的并发读，自然是线程安全的。<br>第二种情况下，如果两个shared_ptr对象A和B管理的是不同对象的指针，则这两个对象完全不相关，支持并发写也容易理解。但如果A和B管理的是同一个对象P的指针，则A和B需要维护一块共享的内存区域，该区域记录P指针当前的引用计数。对A和B的并发写必然涉及对该引用计数内存区的并发修改，这需要boost做额外的工作，也是本文分析的重点。</p>
<p>另外weak_ptr和shared_ptr紧密相关，用户可以从weak_ptr构造出shared_ptr，也可以从shared_ptr构造weak_ptr，但是weak_ptr不涉及到对象的生命周期。由于shared_ptr的线程安全性是和weak_ptr耦合在一起的，本文的分析也涉及到weak_ptr。</p>
<p>下面先从总体上看一下shared_ptr和weak_ptr的实现。</p>
<h3 id="shared-ptr的结构图"><a href="#shared-ptr的结构图" class="headerlink" title="shared_ptr的结构图"></a>shared_ptr的结构图</h3><p>以下是从boost源码提取出的shared_ptr和weak_ptr的类图。<br><img src="/images/cpp/ptr_1.png" alt=""></p>
<p>我们首先忽略虚线框内的weak_ptr部分。最高层的shared_ptr就是用户直接使用的类，它提供shared_ptr的构造、复制、重置(reset函数）、解引用、比较、隐式转换为bool等功能。它包含一个指向被管理对象的指针，用来实现解引用操作，并且组合了一个shared_count对象，用来操作引用计数。<br>但shared_count类还不是引用计数类，它只是包含了一个指向引用计数类sp_counted_base的指针，功能上是对sp_counted_base操作的封装。shared_count对象的创建、复制和删除等操作，包含着对sp_counted_base的增加和减小引用计数的操作。<br>最后sp_counted_base类才保存了引用计数，并且对引用计数字段提供无锁保护。它也包含了一个指向被管理对象的指针，是用来删除被管理的对象的。sp_counted_base有三个派生类，分别处理用户指定Deleter和Allocator的情况：</p>
<ol>
<li>sp_counted_impl_p：用户没有指定Deleter和Allocator</li>
<li>sp_counted_impl_pd：用户指定了Deleter，没有指定Allocator</li>
<li>sp_counted_impl_pda：用户指定了Deleter和 Allocator<br>创建指针P的第一个shared_ptr对象的时候，子对象shared_count同时被建立， shared_count根据用户提供的参数选择创建一个特定的sp_counted_base派生类对象X。之后创建的所有管理P的shared_ptr对象都指向了这个独一无二的X。<br>然后再看虚线框内的weak_ptr就清楚了。weak_ptr和shared_ptr基本上类似，只不过weak_ptr包含的是weak_count子对象，但weak_count和shared_count也都指向了sp_counted_base。<br>如果上面的文字还不够清楚，下面的代码就能说明问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shared_ptr&lt;SomeObject&gt; SP1(new SomeObject());</div><div class="line">shared_ptr&lt;SomeObject&gt; SP2=SP1;</div><div class="line">weak_ptr&lt;SomeObject&gt; WP1=SP1;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>执行完以上代码后，内存中会创建以下对象实例，其中红色箭头表示指向引用计数对象的指针，黑色箭头表示指向被管理对象的指针。<br><img src="/images/cpp/ptr_2.png" alt=""></p>
<p>从上面可以清楚的看出，SP1、SP2和WP1指向了同一个sp_counted_impl_p对象，这个sp_counted_impl_p对象保存引用计数，是SP1、SP2和WP1等三个对象共同操作的内存区。多线程并发修改SP1、SP2和WP1，有且只有sp_counted_impl_p对象会被并发修改，因此sp_counted_impl_p的线程安全性是shared_ptr以及weak_ptr线程安全性的关键问题。而sp_counted_impl_p的线程安全性是在其基类sp_counted_base中实现的。下面将着重分析sp_counted_base的代码。</p>
<h3 id="引用计数类sp-counted-base"><a href="#引用计数类sp-counted-base" class="headerlink" title="引用计数类sp_counted_base"></a>引用计数类sp_counted_base</h3><p>幸运的是，sp_counted_base的代码量很小，下面全文列出来，并添加有注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">class sp_counted_base</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">     // 禁止复制</div><div class="line">    sp_counted_base( sp_counted_base const &amp; );</div><div class="line">    sp_counted_base &amp; operator= ( sp_counted_baseconst &amp; );</div><div class="line"> </div><div class="line">     // shared_ptr的数量</div><div class="line">    long use_count_;  </div><div class="line">     // weak_ptr的数量+1</div><div class="line">    long weak_count_;      </div><div class="line"> </div><div class="line">public:</div><div class="line">     // 唯一的一个构造函数，注意这里把两个计数都置为1</div><div class="line">    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )&#123;    &#125;</div><div class="line"> </div><div class="line">     // 虚基类，因此可以作为基类</div><div class="line">    virtual ~sp_counted_base()&#123;    &#125;</div><div class="line"> </div><div class="line">     // 子类需要重载，用operator delete或者Deleter删除被管理的对象</div><div class="line">    virtual void dispose() = 0;</div><div class="line"> </div><div class="line">     // 子类可以重载，用Allocator等删除当前对象</div><div class="line">    virtual void destroy()&#123;</div><div class="line">        delete this;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    virtual void * get_deleter( sp_typeinfo const &amp; ti ) = 0;</div><div class="line"> </div><div class="line">     // 这个函数在根据shared_count复制shared_count的时候用到</div><div class="line">     // 既然存在一个shared_count作为源，记为A，则只要A不释放，</div><div class="line">     // use_count_就不会被另一个线程release()为1。</div><div class="line">     // 另外，如果一个线程把A作为复制源，另一个线程释放A，执行结果是未定义的。</div><div class="line">     void add_ref_copy()&#123;</div><div class="line">        _InterlockedIncrement( &amp;use_count_ );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     // 这个函数在根据weak_count构造shared_count的时候用到</div><div class="line">     // 这是为了避免通过weak_count增加引用计数的时候，</div><div class="line">     // 另外的线程却调用了release函数，清零use_count_并释放了指向的对象</div><div class="line">    bool add_ref_lock()&#123;</div><div class="line">        for( ;; )</div><div class="line">        &#123;</div><div class="line">            long tmp = static_cast&lt; long const volatile&amp; &gt;( use_count_ );</div><div class="line">            if( tmp == 0 ) return false;</div><div class="line"> </div><div class="line">            if( _InterlockedCompareExchange( &amp;use_count_, tmp + 1, tmp ) == tmp )return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    void release()&#123;</div><div class="line">        if( _InterlockedDecrement( &amp;use_count_ ) == 0 )</div><div class="line">        &#123;</div><div class="line">              // use_count_从1变成0的时候，</div><div class="line">              // 1. 释放对象</div><div class="line">              // 2. 对weak_count_执行一次递减操作。这是因为在初始化的时候（use_count_从0变1时），weak_count初始值为1</div><div class="line">            dispose();</div><div class="line">            weak_release();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    void weak_add_ref()&#123;</div><div class="line">        _InterlockedIncrement( &amp;weak_count_ );</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     // 递减weak_count_；且在weak_count为0的时候，把自己删除</div><div class="line">    void weak_release()&#123;</div><div class="line">        if( _InterlockedDecrement( &amp;weak_count_ ) == 0 )</div><div class="line">        &#123;</div><div class="line">            destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">     // 返回引用计数。注意如果用户没有额外加锁，引用计数完全可能同时被另外的线程修改掉。</div><div class="line">    long use_count() const&#123;</div><div class="line">        return static_cast&lt;long const volatile &amp;&gt;( use_count_ );</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>代码中的注释已经说明了一些问题，这里再重复一点：use<em>count</em>字段等于当前shared_ptr对象的数量，weak<em>count</em>字段等于当前weak_ptr对象的数量加1。<br>首先不考虑weak_ptr的情况。根据对shared_ptr类的代码分析（代码没有列出来，但很容易找到），shared_ptr之间的复制都是调用add_ref_copy和release函数进行的。假设两个线程分别对SP1和SP2进行操作，操作的过程无非是以下三种情况：</p>
<ol>
<li>SP1和SP2都递增引用计数，即add_ref_copy被并发调用，也就是两个_InterlockedIncrement（&amp;use<em>count</em>)并发执行，这是线程安全的。</li>
<li>SP1和SP2都递减引用计数，即release被并发调用，也就是_InterlockedDecrement(&amp;use<em>count</em> )并发执行，这也是线程安全的。只不过后执行的线程负责删除对象。</li>
<li>SP1递增引用计数，调用add_ref_copy；SP2递减引用计数，调用release。由于SP1的存在，SP2的release操作无论如何都不会导致use<em>count</em>变为零，也就是说release中if语句的body永远不会被执行。因此，这种情况就化简为_InterlockedIncrement（&amp;use<em>count</em>)和_InterlockedDecrement( &amp;use<em>count</em> )的并发执行，仍然是线程安全的。</li>
</ol>
<p>然后考虑weak_ptr。如果是weak_ptr之间的操作，或者从shared_ptr构造weak_ptr，都不涉及到use<em>count</em>的操作，只需要调用weak_add_ref和weak_release来操作weak<em>count</em>。与上面的分析相同，<code>_InterlockedIncrement和_InterlockedDecrement</code>保证了weak_add_ref和weak_release并发操作的线程安全性。但如果存在从weak_ptr构造shared_ptr的操作，则需要考虑在构造weak_ptr的过程中，被管理的对象已经被其他线程被释放的情况。如果从weak_ptr构造shared_ptr仍然是通过add_ref_copy函数完成的，则可能发生以下错误情况：<br> <table><br> <tr><br> <td></td><br> <td>线程1，从weak_ptr创建shared_ptr</td><br> <td>线程2，释放目前唯一存在的shared_ptr</td><br> </tr><br> <tr><br> <td>1</td><br> <td>判断use<em>count</em>大于0，等待执行add_ref_copy</td><br> <td></td><br> </tr><br>  <tr><br> <td>2</td><br> <td></td><br> <td>调用release，use_count–。发现use_count为0，删除被管理的对象</td><br> </tr><br>   <tr><br> <td>3</td><br> <td><br>开始执行add_ref_copy，导致 use_count递增。<br>发生错误,use_count==1，但是对象已经被删除了</td><br> <td></td><br> </tr><br> </table></p>
<p>我们自然会想，线程1在第三行结束后，再判断一次use_count是否为1，如果是1，认为对象已经删除，判断失败不就可以了吗。其实是行不通的，下面是一个反例。</p>
<table><br> <tr><br> <td></td><br> <td>线程1，从weak_ptr创建shared_ptr</td><br> <td>线程2，释放目前唯一存在的shared_ptr</td><br> <td>线程3，从weak_ptr创建shared_ptr</td><br> </tr><br> <tr><br> <td>1</td><br> <td>判断use<em>count</em>大于0，等待执行add_ref_copy</td><br> <td></td><br>  <td></td><br> </tr><br>  <tr><br> <td>2</td><br> <td></td><br> <td>调用release，use_count–。发现use_count为0，删除被管理的对象</td><br> <td>判断use<em>count</em>大于0，等待执行add_ref_copy</td><br> </tr><br>   <tr><br> <td>3</td><br> <td></td><br> <td>调用release，use_count–。发现use_count为0，删除被管理的对象</td><br> <td></td><br> </tr><br> <tr><br> <td>4</td><br> <td>开始执行add_ref_copy，导致 use_count递增。</td><br> <td></td><br> <td></td><br> </tr><br> <tr><br> <td>5</td><br> <td></td><br> <td></td><br> <td>执行add_ref_copy，导致 use_count递增。</td><br> </tr><br> <tr><br> <td>6</td><br> <td>发现use<em>count</em> != 1，判断执行成功。<br>发生错误,use_count==2，但是对象已经被删除了</td><br> <td></td><br> <td>发现use<em>count</em> != 1，判断执行成功。<br>发生错误,use_count==2，但是对象已经被删除了</td><br> </tr><br><br> </table>

<p>实际上，boost从weak_ptr构造shared_ptr不是调用add_ref_copy，而是调用add_ref_lock函数。add_ref_lock是典型的无锁修改共享变量的代码，下面再把它的代码复制一遍，并添加证明注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">bool add_ref_lock()&#123;</div><div class="line">    for( ;; )</div><div class="line">    &#123;</div><div class="line">        // 第一步，记录下use_count_</div><div class="line">        long tmp = static_cast&lt; long const volatile&amp; &gt;( use_count_ );</div><div class="line">        // 第二步，如果已经被别的线程抢先清0了，则被管理的对象已经或者将要被释放，返回false</div><div class="line">        if( tmp == 0 ) return false;</div><div class="line">        // 第三步，如果if条件执行成功，</div><div class="line">     // 说明在修改use_count_之前,use_count仍然是tmp，大于0</div><div class="line">        // 也就是说use_count_在第一步和第三步之间，从来没有变为0过。</div><div class="line">        // 这是因为use_count一旦变为0，就不可能再次累加为大于0</div><div class="line">        // 因此，第一步和第三步之间，被管理的对象不可能被释放，返回true。</div><div class="line">        if( _InterlockedCompareExchange( &amp;use_count_, tmp + 1, tmp ) == tmp )return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的注释中，用到了一个没有被证明的结论，“use_count一旦变为0，就不可能再次累加为大于0”。下面四条可以证明它。</p>
<ol>
<li>use<em>count</em>是sp_counted_base类的private对象，sp_counted_base也没有友元函数，因此use<em>count</em>不会被对象外的代码修改。</li>
<li>成员函数add_ref_copy可以递增use<em>count</em>，但是所有对add_ref_copy函数的调用都是通过一个shared_ptr对象执行的。既然存在shared_ptr对象，use_count在递增之前一定不是0。</li>
<li>成员函数add_ref_lock可以递增use<em>count</em>，但正如add_ref_lock代码所示，执行第三步的时候，tmp都是大于0的，因此add_ref_lock不会使use<em>count</em>从0递增到1</li>
<li>其它成员函数从来不会递增use<em>count</em><br>至此，我们可以放下心来，只要add_ref_lock返回true，递增引用计数的行为就是成功的。因此从weak_ptr构造shared_ptr的行为也是完全确定的，要么add_ref_lock返回true，构造成功，要么add_ref_lock返回false，构造失败。<br>综上所述，多线程通过不同的shared_ptr或者weak_ptr对象并发修改同一个引用计数对象sp_counted_base是线程安全的。而sp_counted_base对象是这些智能指针唯一操作的共享内存区，因此最终的结果就是线程安全的。<br>其它操作<br>前面我们分析了，不同的shared_ptr对象可以被多线程同时修改。那其它的问题呢，同一个shared_ptr对象可以对多线程同时修改吗？我们必须要注意到，前面所有的同步都是针对引用计数类sp_counted_base进行的，shared_ptr本身并没有任何同步保护。我们看下面boost文档举出来的非线程安全的例子</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// thread A</div><div class="line">p3.reset(new int(1));</div><div class="line">// thread B</div><div class="line">p3.reset(new int(2)); // undefined, multiple writes</div></pre></td></tr></table></figure>
<p>下面是shared_ptr类相关的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;class Y&gt;</div><div class="line">void reset(Y * p)</div><div class="line">&#123;</div><div class="line">     this_type(p).swap(*this);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void swap(shared_ptr&lt;T&gt; &amp; other)</div><div class="line">&#123;</div><div class="line">     std::swap(px, other.px);</div><div class="line">     pn.swap(other.pn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，reset执行了两个修改成员变量的操作，thread A和thread B的执行结果可能是非法的。。<br>但是仿照内置对象的语义，boost提供了若干个原子函数，支持通过这些函数并发修改同一个shared_ptr对象。这包括atomic_store、atomic_exchange、atomic_compare_exchange等。以下是实现的代码，不再详细分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">void atomic_store( shared_ptr&lt;T&gt; * p, shared_ptr&lt;T&gt; r )&#123;</div><div class="line">    boost::detail::spinlock_pool&lt;2&gt;::scoped_lock lock( p );</div><div class="line">    p-&gt;swap( r );</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template&lt;class T&gt;</div><div class="line">shared_ptr&lt;T&gt; atomic_exchange( shared_ptr&lt;T&gt; * p, shared_ptr&lt;T&gt; r )&#123;</div><div class="line">    boost::detail::spinlock &amp; sp = boost::detail::spinlock_pool&lt;2&gt;::spinlock_for( p );</div><div class="line"> </div><div class="line">    sp.lock();</div><div class="line">    p-&gt;swap( r );</div><div class="line">    sp.unlock();</div><div class="line"> </div><div class="line">    return r;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">template&lt;class T&gt;</div><div class="line">bool atomic_compare_exchange( shared_ptr&lt;T&gt; * p, shared_ptr&lt;T&gt; * v, shared_ptr&lt;T&gt; w )&#123;</div><div class="line"> </div><div class="line">    boost::detail::spinlock &amp; sp = boost::detail::spinlock_pool&lt;2&gt;::spinlock_for( p );</div><div class="line">    sp.lock();</div><div class="line">    if( p-&gt;_internal_equiv( *v ) )&#123;</div><div class="line">        p-&gt;swap( w );</div><div class="line">        sp.unlock();</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        shared_ptr&lt;T&gt; tmp( *p );</div><div class="line">        sp.unlock();</div><div class="line">        tmp.swap( *v );</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结<br>正如boost文档所宣称的，boost为shared_ptr提供了<code>与内置类型同级别的线程安全性</code>。这包括：</p>
<ol>
<li>同一个shared_ptr对象可以被多线程同时读取。</li>
<li>不同的shared_ptr对象可以被多线程同时修改。</li>
<li>同一个shared_ptr对象不能被多线程直接修改，但可以通过原子函数完成。</li>
</ol>
<p>如果把上面的表述中的”shared_ptr”替换为“内置类型”也完全成立。<br>最后，整理这个东西的时候我也发现有些关键点很难表述清楚，这也是由于线程安全性本身比较难严格证明。如果想要完全理解，还是建议阅读shared_ptr完整的代码。shared_ptr在windows下的源代码我已经单独从boost中提取了出来，整理成了单独的文件，且去掉了不相关的条件编译指令。</p>
<p>参考 <a href="http://blog.csdn.net/jiangfuqiang/article/details/8292906" target="_blank" rel="external">http://blog.csdn.net/jiangfuqiang/article/details/8292906</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/11/libevent学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/11/libevent学习/" itemprop="url">libevent学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-11T23:12:55+08:00">
                2015-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>uscxml基于libevent库，使用到了里面到定时器，socket等功能</p>
<h3 id="Libevent-亮点："><a href="#Libevent-亮点：" class="headerlink" title="Libevent 亮点："></a>Libevent 亮点：</h3><p>事件驱动（event-driven），高性能;<br>轻量级，专注于网络，不如ACE那么臃肿庞大；<br>跨平台，支持Windows、Linux、*BSD和Mac Os；<br>支持多种I/O多路复用技术， epoll、poll、dev/poll、select和kqueue等；<br>支持I/O，定时器和信号等事件；<br>注册事件优先级；</p>
<h3 id="Reactor的事件处理机制"><a href="#Reactor的事件处理机制" class="headerlink" title="Reactor的事件处理机制"></a>Reactor的事件处理机制</h3><h4 id="反应机制原理"><a href="#反应机制原理" class="headerlink" title="反应机制原理"></a>反应机制原理</h4><p>首先来回想一下普通函数调用的机制：程序调用某函数?函数执行，程序等待?函数将结果和控制权返回给程序?程序继续处理。</p>
<p>Reactor释义“反应堆”，是一种事件驱动机制。和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor逆置了事件处理流程，<code>应用程序需要提供相应的接口并注册到Reactor上，如果相应的时间发生，Reactor将主动调用应用程序注册的接口</code>，这些接口又称为“回调函数”。使用Libevent也是想Libevent框架注册相应的事件和回调函数；当这些时间发声时，Libevent会调用这些回调函数处理相应的事件（I/O读写、定时和信号）。</p>
<p> 这个概念非常常见，nodejs的事件机制，python等事件机制（tornado ioloop）c#等委托事件，linux的epoll机制</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；<br>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；<br>3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；<br>4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p>
<h3 id="使用libevent"><a href="#使用libevent" class="headerlink" title="使用libevent"></a>使用libevent</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1）首先初始化libevent库，并保存返回的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct event_base * base = event_init();</div></pre></td></tr></table></figure></p>
<p>实际上这一步相当于初始化一个Reactor实例；在初始化libevent后，就可以注册事件了。</p>
<p>2）初始化事件event，设置回调函数和关注的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">evtimer_set(&amp;ev, timer_cb, NULL);</div></pre></td></tr></table></figure></p>
<p>事实上这等价于调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event_set(&amp;ev, -1, 0, timer_cb, NULL);</div></pre></td></tr></table></figure></p>
<p>3）设置event从属的event_base</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event_base_set(base, &amp;ev);</div></pre></td></tr></table></figure>
<p>这一步相当于指明event要注册到哪个event_base实例上；</p>
<p>4）是正式的添加事件的时候了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event_add(&amp;ev, timeout);</div></pre></td></tr></table></figure></p>
<p>基本信息都已设置完成，只要简单的调用event_add()函数即可完成，其中timeout是定时值；<br>这一步相当于调用Reactor::register_handler()函数注册事件。</p>
<p>5）程序进入无限循环，等待就绪事件并执行事件处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">event_base_dispatch(base);</div></pre></td></tr></table></figure></p>
<p>代码实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct event ev;</div><div class="line">struct timeval tv;</div><div class="line">void time_cb(int fd, short event, void *argc)</div><div class="line">&#123;</div><div class="line">    printf(&quot;timer wakeup/n&quot;);</div><div class="line">    event_add(&amp;ev, &amp;tv); // reschedule timer</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    struct event_base *base = event_init();</div><div class="line">    tv.tv_sec = 10; // 10s period</div><div class="line">    tv.tv_usec = 0;</div><div class="line">    evtimer_set(&amp;ev, time_cb, NULL);</div><div class="line">    event_add(&amp;ev, &amp;tv);</div><div class="line">    event_base_dispatch(base);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="事件处理流程"><a href="#事件处理流程" class="headerlink" title="事件处理流程"></a>事件处理流程</h4><p>当应用程序向libevent注册一个事件后，libevent内部是怎么样进行处理的呢？下面就给出了这一基本流程。</p>
<ul>
<li>首先应用程序准备并初始化event，设置好事件类型和回调函数；这对应于前面第步骤2和3；</li>
<li>向libevent添加该事件event。对于定时事件，libevent使用一个<code>最小根堆管理</code>，key为超时时间；对于Signal和I/O事件，libevent将其放入到等待链表（wait list）中，这是一个双向链表结构；</li>
<li>程序调用event_base_dispatch()系列函数进入无限循环，等待事件。</li>
</ul>
<p> 以select()函数为例；每次循环前libevent会检查定时事件的最小超时时间tv，根据tv设置select()的最大等待时间，以便于后面及时处理超时事件；</p>
<p>当select()返回后，首先检查超时事件，然后检查I/O事件；<br>Libevent将所有的就绪事件，放入到激活链表中；<br>然后对激活链表中的事件，调用事件的回调函数执行事件处理；<br><img src="/images/cpp/libevent_1.jpg" alt=""></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>1）头文件<br>主要就是event.h：事件宏定义、接口函数声明，主要结构体event的声明；<br>2）内部头文件<br>xxx-internal.h：内部数据结构和函数，对外不可见，以达到信息隐藏的目的；<br>3）libevent框架<br>event.c：event整体框架的代码实现；<br>4）对系统I/O多路复用机制的封装<br>epoll.c：对epoll的封装；<br>select.c：对select的封装；<br>devpoll.c：对dev/poll的封装;<br>kqueue.c：对kqueue的封装；<br>5）定时事件管理<br>min-heap.h：其实就是一个以时间作为key的小根堆结构；<br>6）信号管理<br>signal.c：对信号事件的处理；<br>7）辅助功能函数<br>evutil.h 和evutil.c：一些辅助功能函数，包括创建socket pair和一些时间操作函数：加、减和比较等。<br>8）日志<br>log.h和log.c：log日志函数<br>9）缓冲区管理<br>evbuffer.c和buffer.c：libevent对缓冲区的封装；<br>10）基本数据结构<br>compat/sys下的两个源文件：queue.h是libevent基本数据结构的实现，包括链表，双向链表，队列等；_libevent_time.h：一些用于时间操作的结构体定义、函数和宏定义；<br>11）实用网络库<br>http和evdns：是基于libevent实现的http服务器和异步dns查询库；</p>
<h3 id="Timer小根堆"><a href="#Timer小根堆" class="headerlink" title="Timer小根堆"></a>Timer小根堆</h3><p> Libevent使用堆来管理Timer事件，其key值就是事件的超时时间，源代码位于文件min_heap.h中。<br>所有的数据结构书中都有关于堆的详细介绍，向堆中插入、删除元素时间复杂度都是O(lgN)，N为堆中元素的个数，而获取最小key值（小根堆）的复杂度为O(1)。堆是一个完全二叉树，基本存储方式是一个数组。</p>
<p>学习资料：<br><a href="http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod" target="_blank" rel="external">http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod</a><br><a href="http://libevent.org/" target="_blank" rel="external">http://libevent.org/</a><br><a href="https://www.cnblogs.com/lfsblack/p/5498556.html" target="_blank" rel="external">https://www.cnblogs.com/lfsblack/p/5498556.html</a> （推荐）<br><a href="http://blog.chinaunix.net/uid-8048969-id-5008922.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-8048969-id-5008922.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/03/站在对象模型的类端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/03/站在对象模型的类端/" itemprop="url">站在对象模型的类端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-03T23:47:56+08:00">
                2015-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板的实例化"><a href="#模板的实例化" class="headerlink" title="模板的实例化"></a>模板的实例化</h2><p>一个模板只有被使用到，才会被实例化，否则不会被实例化。对于一个实例化后的模板来说，未被调用的成员函数将不会被实例化，只有成员函数被使用时，C++标准才要求实例化他们。其原因，有两点：</p>
<ul>
<li>空间和时间效率的考虑，如果模板类中有100个成员函数，对某个特定类型只有2个函数会被使用，针对另一个特定类型只会使用3个，那么如果将剩余的195个函数实例化将浪费大量的时间和空间。</li>
<li>使模板有最大的适用性。并不是实例化出来的每个类型都支持所有模板的全部成员函数所需要的运算符。如果只实例化那些真正被使用的成员函数的话，那么原本在编译期有错误的类型也能够得到支持。</li>
</ul>
<p>可以明确的要求在一个文件中将整个类模板实例化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template class Point3d&lt;float&gt;;</div></pre></td></tr></table></figure>
<p>也可以显示指定实例化一个模板类的成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template float Point3d&lt;float&gt;::X() const;</div></pre></td></tr></table></figure>
<p>或是针对一个模板函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template Point3d&lt;float&gt; operator+(</div><div class="line">    const Point3d&lt;float&gt;&amp;, const Point3d&lt;float&gt;&amp; );</div></pre></td></tr></table></figure>
<p>模板的错误报告，使用模板并遇到错误的大概都深有体会，那就是一个灾难。</p>
<p>模板的名称决议</p>
<p>一开始先要区分两种意义,一种是C++ 标准所谓的“scope of the template definition”，直译就是“定义模板的范围”。另一种是C++标准所谓的“scope of the temlate instantiation”，可以直译为“实例化模板的范围”。</p>
<p>第一种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// scope of the template definition</div><div class="line">extern double foo ( double );  </div><div class="line">    </div><div class="line">template &lt; class type &gt;  </div><div class="line">class ScopeRules  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">    void invariant() &#123;  </div><div class="line">        _member = foo( _val );  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    type type_dependent() &#123;  </div><div class="line">        return foo( _member );  </div><div class="line">    &#125;  </div><div class="line">    // ...  </div><div class="line">private:  </div><div class="line">    int _val;  </div><div class="line">    type _member;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//scope of the template instantiation  </div><div class="line">extern int foo( int );  </div><div class="line">// ...  </div><div class="line">ScopeRules&lt; int &gt; sr0;  </div><div class="line">sr0.invariant();</div><div class="line">sr0.type_dependent();</div></pre></td></tr></table></figure>
<p>在“scope of the template instantiation ”中 两个foo()都声明在此 scope中。猜猜sr0.invariant() 中调用的是哪个foo()函数，出乎意料，实际调用的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern double foo ( double );</div></pre></td></tr></table></figure></p>
<p>看上去，应该调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int foo( int );</div></pre></td></tr></table></figure></p>
<p>毕竟，_val 的类型是 int 类型，它们才完全匹配。而 sr0.type_dependent()中调用的却在我们意料之中，调用的是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int foo( int );</div></pre></td></tr></table></figure></p>
<p>诸上所述,看上去或合理或不合理的选择，原因在于:</p>
<blockquote>
<p>template 之中， 对于一个非成员名字的决议结果是根据这个 name的使用是否与“用以实例化该模板的参数类型”有关来决定name。如果其使用互不相干，那么就以“scope of the template dclaration”来决定name。如果其使用的互相关联，那么就以“scope of the template instantiation”来决定name.</p>
</blockquote>
<p>对于上面这一段话我的理解比较粗鲁且直接：在模板中，一个非成员名字的决议在于它适不适合在当前决议，当它完全与实例化模板的参数的类型无关的时候，就可以在当前决议下来；如果有关的话，则认为不适合在当前决议下来，将被推迟到实例化这个模板实例化的时候来决议。为什么以与实例化的类型相关不相关来区别适不适合当前决议？一个与实例化类型无关的名字，如果推迟到实例化的时候来决议，将使模板的设计者无所适从，一个模板的设计者能容忍一个与实例化类型无关的名字在他的模板中表现出当前不具有的含义吗？当然不行，那种场面，估计没有一个模板设计者能够hold住。相反，对于一个与实例化类型有关的名字，天生就应该可以根据实例化模板的不同类型表现出不同含义，如果其名字早在模板定义时被决议出来，那就该轮到模板的使用者hold不住了。当然所上完全属一家之言，呸，连一家之言都不算，怎么敢自称“家”。如有不同理解，可当我一派胡言，如果你聊发善心，可以对我赐教一二，当聆听受教。</p>
<h2 id="异常处理-Exception-Handling"><a href="#异常处理-Exception-Handling" class="headerlink" title="异常处理(Exception Handling)"></a>异常处理(Exception Handling)</h2><p>C++的 exception handling 有三个主要的子句组成：</p>
<ul>
<li>一个throw子句。它在程序的某处丢出一个exception，被丢出的exception可以是内建类型，也可以是自定义类型。——抛出exception组件。</li>
<li>一个或多个 catch 子句。 每一个 catch 子句都是一个 exception handler。每个子句可以处理一种类型(也包括其继承类)的exception，在大括号中包含处理代码。——专治各种不服组件。每一个catch子句都可以用来处理某种exception。</li>
<li>一个 try 区段。用大括号包围一系列语句，这些语句有可能抛出exception，从而引发catch 子句的作用。——逮捕各种 exception 组件。</li>
</ul>
<p>当一个 exception 被抛出后，控制权从函数调用中被释放，寻找一个吻合的catch子句，如果各层调用都没有吻合的catch子句，terminate()将被调用。在控制权被放弃后，堆栈中的每一个函数调用也被出栈，这个过程称为unwinding the stack(关于 stack unwinding ,可以参考《C++ Primer》第四版之 17.1.2 Stack Unwinding)，在每一个函数被出栈之前,其局部变量会被摧毁。</p>
<p>异常抛出有可能带来一些问题，比方在一块内存的lock和unlock内存之间，或是在new和delete之间的代码抛出了异常，那么将导致本该进行的unlock或delete操作不能进行。解决方法之一是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void  mumble( void *arena )  </div><div class="line">&#123;  </div><div class="line">    Point *p;  </div><div class="line">    p = new Point;  </div><div class="line">    try &#123;  </div><div class="line">        smLock( arena );  </div><div class="line">        // ...  </div><div class="line">    &#125;  </div><div class="line">    catch ( ... ) &#123;  </div><div class="line">        smUnLock( arena );  </div><div class="line">        delete p;  </div><div class="line">        throw;  </div><div class="line">    &#125;  </div><div class="line">    smUnLock( arena );  </div><div class="line">    delete p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在函数被出栈之前，先截住异常，在unlock和delete之后再将异常原样抛出。new expression的调用不用包括在try块之内是因为，不论在new operator调用时还是构造函数调用时抛出异常，都会在抛出异常之前释放已分配好的资源，所以不用再调用delete 。</p>
<p>另一个办法是，将这些资源管理的问题，封装在一个类对象中，由析构函数释放资源，这样就不需要对代码进行上面那样的处理——利用函数释放控制权之前会析构所有局部对象的原理。</p>
<p>在对单个对象构造过程中抛出异常，会只调用已经构造好的base class object或member class object的析构函数。同样的道理，适用于数组身上，如果在调用构造函数过程中抛出异常，那么之前所有被构造好的元素的析构函数被调用，对于抛出异常的该元素，则遵循关于单个对象构造的原则，然后释放已经分配好的内存。</p>
<p>只有在一个catch子句评估完毕并且知道它不会再抛出exception后，真正的exception object才会被释放。关于 catch子句使用引用还是使用对象来捕获异常，省略。</p>
<h2 id="执行期类型识别（Runtime-Type-Identification-RTTI）"><a href="#执行期类型识别（Runtime-Type-Identification-RTTI）" class="headerlink" title="执行期类型识别（Runtime Type Identification RTTI）"></a>执行期类型识别（Runtime Type Identification RTTI）</h2><ul>
<li>RTTI 只支持多态类，也就是说没有定义虚函数是的类是不能进行 RTTI的。</li>
<li><p>对指针进行dynamic_cast失败会返回NULL ,而对引用的话，识别会抛出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bad_cast exception。</div></pre></td></tr></table></figure>
</li>
<li><p>typeid 可以返回const type_info&amp;，用以获取类型信息。<br>关于1是因为RTTI的实现是通过vptr来获取存储在虚函数表中的type_info* ，事实上为非多态类提供RTTI,也没有多大意义。 2的原因在于指针可以被赋值为0，以表示 no object，但是引用不行。关于3，虽然第一点指出RTTI只支持多态类，但typeid和type_info同样可用于内建类型及所有非多态类。与多态类的差别在于，非多态类的type_info对象是静态取得(所以不能叫“执行期类型识别”)，而多态类的是在执行期获得。</p>
</li>
</ul>
<p>参考：深度探索C++对象模型</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/构造、解构、拷贝 语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/构造、解构、拷贝 语意学/" itemprop="url">构造、解构、拷贝 语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T23:41:22+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="几点类设计原则"><a href="#几点类设计原则" class="headerlink" title="几点类设计原则"></a>几点类设计原则</h2><ul>
<li><p>即使是一个抽象基类，如果它有非静态数据成员，也应该给它提供一个带参数的构造函数，来初始化它的数据成员。或许你可以通过其派生类来初始化它的数据成员（假如nostatic data member为publish或protected）,但这样做的后果则是破坏了数据的封装性，使类的维护和修改更加困难。由此引申，类的data member应当被初始化，且只在其构造函数或其member function中初始化。</p>
</li>
<li><p>不要将析构函数设计为纯虚的，这不是一个好的设计。将析构函数设计为纯虚函数意味着，即使纯虚函数在语法上允许我们只声明而不定义纯虚函数，但还是必须实现该纯虚析构函数，否则它所有的继承类都将遇到链接错误。一个不能派生继承类的抽象类有什么存在的意义？必须定义纯虚析构函数，而不能仅仅声明它的原因在于：每一个继承类的析构函数会被编译器加以扩展，以静态调用方式其每一个基类的析构函数（假如有的话，不论是显示的还是编译器合成的），所以只要任何一个基类的析构函数缺乏定义，就会导致链接失败。矛盾就在这里，纯虚函数的语法，允许只声明而不定义纯虚析构函数，而编译器则死脑筋的看到一个其基类的析构函数声明，则去调用它的实体，而不管它有没有被定义。</p>
</li>
<li><p>真的必要的时候才使用虚函数，不要滥用虚函数。虚函数意味着不小的成本，编译很可能给你的类带来膨胀效应：</p>
<ul>
<li>每一个对象要多负担一个word的vptr。</li>
<li>给每一个构造函数（不论是显示的还是编译器合成的），插入一些代码来初始化vptr，这些代码必须被放在所有基类构造函数的调用之后，但需在任意用户代码之前。没有构造函数则需要合成，并插入代码。</li>
<li>合成一个拷贝构造函数和一个复制操作符（如果没有的话），并插入对vptr的初始化代码，有的话也需要插入vptr的初始化代码。</li>
<li>意味着，如果具有bitwise语意，将不再具有，然后是变大的对象、没有那么高效的构造函数，没有那么高效的复制控制。</li>
</ul>
</li>
<li><p>不能决定一个虚函数是否需要 const ，那么就不要它。</p>
</li>
<li><p>决不在构造函数或析构函数中使用虚函数机制。在构造函数中，每次调用虚函数会被决议为当前构造函数所对应类的虚函数实体，虚函数机制并不起作用。当一个base类的构造函数含有对虚函数vf()的调用，当其派生类derived的构造函数调用基类base的构造函数的时候，其中调用的虚函数vf()是base中的实体，而不是derived中的实体。这是由vptr初始化的位置决定的——在所有基类构造函数调用之后，在程序员供应的代码或是成员初始化队列之前。因构造函数的调用顺序是：有根源到末端，由内而外，所以对象的构造过程可以看成是，从构建一个最基础的对象开始，一步步构建成一个目标对象。析构函数则有着与构造相反的顺序，因此在构造或析构函数中使用虚函数机制，往往不是程序员的意图。若要在构造函数或析构函数中调用虚函数，应当直接以静态方式调用，而不要通过虚函数机制。</p>
</li>
</ul>
<h2 id="构造、复制、析构语意学"><a href="#构造、复制、析构语意学" class="headerlink" title="构造、复制、析构语意学"></a>构造、复制、析构语意学</h2><p>一种所谓的Plain OI’Data声明形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    float x,y,z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>概念上来讲，对于一段这样的C++代码,编译器会为之合成一个默认构造函数、复制构造函数、析构函数、赋值操作符。然而实际上编译器会分析这段代码，并给Point贴上Plain OI’Data标签。编译器在此后对于Point的处理与在C中完全一样,也就是说上述的函数都不会被合成。可见概念上应当由编译器合成的函数，并不一定会合成，编译器只有在必要的时候才会合成它们。由此一来，原本在观念上应该调用这些函数的地方实质上不会调用，而是用其它的方法来完成上面的功能，比方复制控制会用bitwise copy。</p>
<h3 id="对象构造语意学"><a href="#对象构造语意学" class="headerlink" title="对象构造语意学"></a>对象构造语意学</h3><h3 id="无继承情况下的对象构造：略。"><a href="#无继承情况下的对象构造：略。" class="headerlink" title="无继承情况下的对象构造：略。"></a>无继承情况下的对象构造：略。</h3><h4 id="单继承体系下的对象构造"><a href="#单继承体系下的对象构造" class="headerlink" title="单继承体系下的对象构造"></a>单继承体系下的对象构造</h4><p>对于简单定义的一个对象T object;,很明显它的默认构造函数会被调用（被编译器合成的或用户提供的）。但是一个构造函数究竟做了什么，就显得比较复杂了——编译器给了它很多的隐藏代码。编译器一般会做如下扩充操作：</p>
<ul>
<li><p>调用所有虚基类的构造函数，从左到右，从最深到最浅：</p>
<ul>
<li>如果该类被列于成员初始化列表中，任何明确明确指定的参数，都应该被传递过来。若没有列入成员初始化列表中，虚基类的一个默认构造函数被调用（有的话）。</li>
<li>此外，要保证虚基类的偏移量在执行期可存取，对于使用vbptr来实现虚基类的编译器来说，满足这点要求就是对vbptr的初始化。</li>
<li>然而，只有在类对象代表着“most-derived class”时，这些构造函数才可能会被调用。一些支持这个行为的代码会被放进去^注2（直观点说就是，虚基类的构造由最外层类控制)。</li>
</ul>
</li>
<li><p>调用所有基类构造函数，依声明顺序：</p>
<ul>
<li>如果该基类被列入了成员初始化队列，那么所有明确指定的参数，应该被传递过来。</li>
<li>没有列入的话，那么调用其默认构造函数，如果有的话。</li>
<li>如果该基类是第二顺位或之后的基类，this 指针必须被调整。</li>
</ul>
</li>
<li><p>正确初始化vptr,如果有的话。</p>
</li>
<li>调用没有出现在初始化成员列表中的member object的默认构造函数，如果有的话。</li>
<li>记录在成员初始化队列中的数据成员初始化操作以声明的顺序被放进构造函数中。</li>
</ul>
<h4 id="虚拟继承下的构造抑制"><a href="#虚拟继承下的构造抑制" class="headerlink" title="虚拟继承下的构造抑制"></a>虚拟继承下的构造抑制</h4><p>有如下继承体系：</p>
<p><img src="/images/cpp/cpp_10.png" alt=""></p>
<p>根据c++ 语法，Point 的初始化应有most-derived class来施行。也就是说当Vertex3d为most-derived class的时候，应当由它的构造函数来调用Point的构造函数初始化Point子对象，Vertex3d的子对象的构造函数对于Point的调用则应当抑制。如果没有抑制会怎么样?当我们定义Vertex3d cv;时，Vertex3d的构造函数中调用Point的构造函数、而随之调用它的子对象，Point3d和Vertex的<br>构造函数中也调用了Point的构造函数。先不说，对于同一个子对象进行三次初始化是否有效率，更重要的是，这将不可避免的带来错误。由Vertex3d指定的子对象Point的值，会被覆盖掉。</p>
<p>编译器通常使用一个条件变量来表示是否为most-derived class,各构造函数根据这个条件变量来决定是否调用虚基类的构造函数，因此通过控制这个条件变量，就可以抑制非most-derived class调用虚基类的构造函数。当然也有其它的方法来做同样的事。</p>
<h3 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h3><p>设计一个类，并考虑到要以一个对象指定给另一个对象时，有三种选择：</p>
<ul>
<li>什么都不做，采用编译器提供默认行为（bitwise copy或者由编译器合成一个）。</li>
<li>自己提供一个赋值运算符操作。</li>
<li>明确拒绝将一个对象指定给另一个对象。<br>对于第三点，只要将赋值操作符声明为private，且不定义它就可以了。对于第二点，只有在第一点的行为不安全或不正确，或你特别想往其中插入点东西的时候。</li>
</ul>
<p>以下四种情况 copy assignment operator(还是用它的英文名，感觉顺畅点)，不具有bitwise copy语意，也就是说这些情况下，编译器要合成copy assignmentoperator而不能依靠bitwise copy来完成赋值操作，这四种情况与构造函数、拷贝构造函数的情况类似，原因可以参考它们的。四种情况如下：</p>
<ul>
<li>类包含有定义了copy assignment operator的class object成员。</li>
<li>类的基类有copy assignment operator。</li>
<li>类声明有任何虚函数的时候（问题同样会出现在由继承类对象向基类对象拷贝的时候）。</li>
<li>当class继承体系中有虚基类时。<br>在虚拟继承情况下，copy assignment opertator会遇到一个不可避免的问题，virtual base class subobject的复制行为会发生多次，与前面说到的在虚拟继承情况下虚基类被构造多次是一个意思，不同的是在这里不能抑制非most-derivedclass 对virtual base class 的赋值行为。</li>
</ul>
<p>安全的做法是把虚基类的赋值放在最后，避免被覆盖。</p>
<h3 id="对象析构语意学"><a href="#对象析构语意学" class="headerlink" title="对象析构语意学"></a>对象析构语意学</h3><p>只有在基类拥有析构函数，或者object member拥有析构函数的时候，编译器才为类合成析构函数，否则都被视为不需要。</p>
<p>析构的顺序正好与构造相反：</p>
<ul>
<li>本身的析构函数被执行。</li>
<li>以声明的相反顺序调用member object 的析构函数，如果有的话。</li>
<li>重设vptr 指向适当的基类的虚函数表，如果有的话。</li>
<li>以声明相反的顺序调用上一层的析构函数，如果有的话。</li>
<li>如果当前类是 most-derivedclass，那么以构造的相反顺序调用虚基类的析构函数。</li>
</ul>
<p>“在此之前”的叙述并不适合我，我喜欢很直白的方式，按顺序来。书中的方式在于，从最浅显的步骤入手，然后告诉你，做这步之前，你还该做点什么。所以，我以对原文的理解写下这点。Lippman的原文为：</p>
<blockquote>
<p>These constructors, however, may be invoked if, and only if, the class object represents the “most-derived class.” Some mechanism supporting this must be put into place.</p>
</blockquote>
<p>侯捷的译文为：</p>
<blockquote>
<p>如果class object是最底层（most-derived）的class,其constructors可能被调用；某些用以支持这个行为的机制必须被放进来。</p>
</blockquote>
<p>我认为，Lippman在这一句上要说的是，虚基类的构造函数只能由most-derived class调用，而为了支持这一机制，需要插入一些代码来抑制非most-derived class对虚基类构造函数的调用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/22/执行期语意学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/22/执行期语意学/" itemprop="url">执行期语意学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-22T20:27:34+08:00">
                2015-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="new-expression、operator-new-和-placement-new"><a href="#new-expression、operator-new-和-placement-new" class="headerlink" title="new expression、operator new 和 placement new"></a>new expression、operator new 和 placement new</h2><p>之前虽然一直知道有new expression、operator new和placement new，但对于这三个“new”,却不甚了了，这些天从《深度探索C++对象模型》读到new和delete，特意结合《C++ Primer》写下这篇笔记，以作总结。三个虽然都是new，但每个new都不相同各有各的特点，各有各的风味，本文重点在于总结比较这三个“new”，但期间也不忘提一提推倒这三个“new”的哥们——delete。</p>
<p>new expression 和 operator new</p>
<p>一个看起来很简单的new expression运算，其实暗含一些步骤，像这样的一次简单运用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *p=new int (5)实际上包含着两个步骤：</div></pre></td></tr></table></figure></p>
<ul>
<li>调用一个合适的operator new实体分配足够的未类型化的内存。</li>
<li>调用合适的构造函数初始化这块内存，当然int没有构造函数，但是会进行赋值操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*p=5。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>由此可见：new expression和operator new完全不是一回事，但关系不浅——operator new 为new expression分配内存。</p>
<p>摘录一下 《C++ primer》关于对比new expression 和 operator new的一小段话：</p>
<blockquote>
<p>标准库函数 operator new和 operator delete 的命名容易让人误解。与其他operator 函数（如 operator=）不同，这些函数没有重载new或delete expression，实际上，我们不能重定义new或delete expression的行为。</p>
</blockquote>
<p>这段话有两个要点：</p>
<ul>
<li>operator new和operator delete不是new expression和delete expression的重载，它们完全是另外的一个独立的东西，具有不同的语意，这与operator +是对+ expression的重载不同。</li>
<li>new expression和delete expression是不能被重载的，可以看出它们与普通的expression 不同。</li>
<li>operator new其实也是可以直接利用的，譬如当我们只想分配内存，而不愿意进行初始化的时候，我们就可以直接用operator new 来进行。用法如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T* newelements = static_cast&lt;T*&gt;(operator new ( sizeof(T) );</div></pre></td></tr></table></figure>
<p>标准库重载有两个版本的operator new，分别为单个对象和数组对象服务，单个对象版本的<br>提供给分配单个对象new expression调用，数组版的提供给分配数组的 new expression 调<br>用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void *operator new(size_t);       // allocate an object</div><div class="line">void *operator new[](size_t);     // allocate an array</div></pre></td></tr></table></figure></p>
<p>我们可以分别重载这两个版本，来定义我们自己的分配单个对象或对象数组的内存方式。当我们自己在重载operator new时，不一定要完全按照上面两个版本的原型重载，唯一的两个要求是：返回一个void*类型和第一个参数的类型必须为size_t。</p>
<p>还要注意的是，在类中重载的operator new和operator delete是隐式静态的，因为前者运行于对象构造之前，后者运行与对象析构之后，所以他们不能也不应该拥有一个this指针来存取数据。另外，new expression 默认调用的是单参数的operator new——上面声明的那种，而其它不同形式的重载，则只能显式调用了。</p>
<p>delete expression与new expression相对应，而operator delete则与operator new对应。<br>依上所述，则不难推断出关于delete expression和operator delete之间的关系以及一些特性，此略。</p>
<p>当使用new expression来动态分配数组的时候，Lippman在《深度探索C++对象模型》中指出：</p>
<ul>
<li>当分配的类型有一个默认构造函数的时候，new expression将调用一个所谓的vec_new()函数来分配内存，而不是operator new内存。但我在VC ++ 20102上测试的结果却是，不论有没有构造函数，new expression都是调用operator new来分配内存，并在此之后，调用默认构造函数逐个初始化它们，而不调用所谓的vec_new()，也许cfront确实离我们有点遥远。</li>
</ul>
<h2 id="两个-delete-后的问题"><a href="#两个-delete-后的问题" class="headerlink" title="两个 delete 后的问题"></a>两个 delete 后的问题</h2><p>最近在网上看到两个关于指针 delete 后的问题。第一种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int;</div><div class="line">delete p;</div><div class="line">delete p;// p为什么能delete两次，而程序运行的时候还不报错。</div></pre></td></tr></table></figure></p>
<p>第二种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int* p = new int ;</div><div class="line">delete p;</div><div class="line">*p = 5;     //delete后对*p进行再赋值居然也可以（他的平台上运行并没有引发什么错误）？</div></pre></td></tr></table></figure></p>
<p>在回答这两个问题之前，我们先想想delete p; 这一语句意味着什么？p指向一个地址，以该地址为起始地址保存有一个int变量（虽然该变量并没有进行初始化），delete p之后p所指向的地址空间被释放，也就是说这个int变量的生命结束，但是p仍旧是一个合法的指针，它仍旧指向原来的地址，而且该地址仍旧代表着一个合法的程序空间。与delete之前唯一的不同是，你已经丧失了那快程序空间的所有权。这带来一个什么样的问题？你租了一间储物室（int* p = new int;），后来退租了（delete p;），但你却保存了出入该储物室的钥匙（指针p）没有归还。拥有这片钥匙，你或许什么都不做，这自然没有问题。<br>但是：你或许出于好心，又跑过去告诉房东，“Hi！这储物室已经退租了（第一种情况）”。哦噢，会发生什么？我们假设此时这个房子已经有了新的租客。愚笨的房东直接相信了你的话，认为这<br>个储物室空着，把它又租给新的人。于是一间只能给一个人用的储物室，却租给了两个人，再之后各种难以预料的情况就会发生。</p>
<p>又或许，你很无耻，你虽然退租，但却想用你的钥匙依旧享有储物室的使用权（第二种情况），结果呢，你存在这间储物室的东西可能会被现在的租客丢掉，而你也可能把他的东西丢掉，腾出空间来放你的。</p>
<p>回到上面的程序上来，毫无疑问的是上面的程序在语法上来讲是合乎规范的，但是暗藏着很大<br>的逻辑错误，不论你对一块已经释放的内存再度delete，还是再度给它赋值，都暗含着很大<br>的危险，因为当你delete后，就代表着将这块内存归还。而这块被归还的内存很可能已经被再<br>度分配出去，此时不论是你再度delete还是重新赋值，都将破坏其它代码的数据，同时你存<br>储在其中的数据也很容易被覆盖。至于报不报错，崩不崩溃，这取决于有一个怎么样的“房东”，<br>聪明且负责的“房东”会阻止你上述的行为——终止你的程序，懒惰的房东，则听之任之。</p>
<p>上述情况下的指针p被称为野指针——指向了一块“垃圾内存”，或者说指向了一块不应该读写的<br>内存。避免野指针的好方法是，当一个指针变为野指针的时候，马上赋值为NULL，其缘由在<br>于，你可以很容易的判断一个指针是否为NULL,却难以抉择其是否为野指针。而且，delete<br>一个空指针，不会做任何操作，因此总是安全的。</p>
<h2 id="不用一个基类指针指向派生类数组？"><a href="#不用一个基类指针指向派生类数组？" class="headerlink" title="不用一个基类指针指向派生类数组？"></a>不用一个基类指针指向派生类数组？</h2><p>《深度探索C++对象模型》中指出，不要用一个基类指针指向派生类的数组。因为在他的cfront中的vec_delete是根据被删除指针的类型来调用析构函数——也就是说虚函数机制在这儿不起作用了。照这样的思路来说，对一个派生类的数组依次调用其基类的析构函数，显然大多时候不能正确析构——派生类一般大于其基类。但是我感兴趣的一点是，这么多年过去了，这样一个不太合理的设计是否有所改进呢？说它不太合理是，以C++编程者的思路，在这样一种情况下，它应该支持多态，而且在这种情况下支持多态并不需要太复杂的机制和代价。我在vc++2008和vc++ 2010下的结果是：是的，有与cfront不同，它支持多态。</p>
<p>我的测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class point&#123;</div><div class="line">public:</div><div class="line">        virtual ~point()&#123;</div><div class="line">            std::cout&lt;&lt;&quot;point::~point()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int  a;</div><div class="line">&#125;;</div><div class="line">class point3d:public point&#123;</div><div class="line">public:</div><div class="line">    virtual ~point3d()</div><div class="line">        &#123;</div><div class="line">            std::cout&lt;&lt;&quot;point3d::~point3d()&quot;&lt;&lt;std::endl;</div><div class="line">        &#125;</div><div class="line">private:</div><div class="line">    int b;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    point *p=new point3d[2];</div><div class="line">    delete[] p;</div><div class="line">    system(&quot;pause&quot;);</div><div class="line">&#125; ;</div></pre></td></tr></table></figure>
<p>输出的结果，也令人满意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div><div class="line">point3d::~point3d()</div><div class="line">point::~point()</div></pre></td></tr></table></figure>
<p>确实调用了派生类的析构函数，而非基类的析构函数。</p>
<p>即使如此，是否能安心的使用一个基类指针指向派生类数组？我不太安心！——对于基类的析构函数是否为虚函数没有把握。所以最好还是不要把一个基类的指针指向派生类数组。非得这么做？那么我认为delete的时候将之类类型转换为派生类就差不多了，可以这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete[] static_cast&lt;point3d*&gt;(p);</div></pre></td></tr></table></figure>
<p>似乎不必要像Lippman说的这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( int ix = 0; ix &lt; elem_count; ++ix ) </div><div class="line">&#123;  </div><div class="line">    Point3d *p = &amp;((Point3d*)ptr)[ ix ];  </div><div class="line">    delete p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="placement-operator-new"><a href="#placement-operator-new" class="headerlink" title="placement operator new"></a>placement operator new</h2><p>placement operator new用来在指定地址上构造对象，要注意的是，它并不分配内存，仅仅是对指定地址调用构造函数。其调用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point3d;</div></pre></td></tr></table></figure></p>
<p>观其名字可知，它是operator new的一个重载版本。它的实现方式异常简单，传回一个指针即 可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void* operator new(site_t,void *p)</div><div class="line">&#123;</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不必要惊讶于它的简单，《深度探索C++对象模型》中Lippman告诉我们，它有另一半重要的工作是被扩充而来。我在想，扩充一个类中定义的placement operator new还好说，但是要如何 扩充一个库中提供的placement operator new呢？毕竟它要放之四海而皆准，我原以为这其中 有什么高超的技巧。后来我则坚信根本就没有什么扩充，placement operator new 也并不强 大。</p>
<p>我先明确调用了 placement operator new ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=(point*)operator new(sizeof(point), p) ;</div></pre></td></tr></table></figure></p>
<p>如我所料，输出结果显示（我在point的默认构造函数和placement operator new中间各输 出一句不同的话），此时 point的默认构造函数并不会被调用。然后我通过new expression 的方式来间接调用placement operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">point *pt=new(p) point();</div></pre></td></tr></table></figure></p>
<p>这个时候 point 的默认的构造函数被调用了。可见 placement operator new并没有什么奇特 的地方，它与一般的operator new不同处在于，它不会申请内存。它也不会在指定的地址调用 构造函数，而调用构造函数的的全部原因在于new expression总是先调用一个匹配参数的 operator new然后再调用指定类型的匹配参数的构造函数，而说到底 placement operator new 也是一个operator new。</p>
<p>通过一个placement operator new构建的一个对象，如果你使用delete来撤销对象，那么其内 存也被回收，如果想保存内存而析构对象，好的办法是显示调用其析构函数。</p>
<p>看一份代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct Base &#123; int j; virtual void f(); &#125;;</div><div class="line">struct Derived : Base &#123; void f(); &#125;;</div><div class="line">void fooBar() &#123;  </div><div class="line">   Base b;  </div><div class="line">   b.f(); // Base::f() invoked  </div><div class="line">   b.~Base();  </div><div class="line">   new ( &amp;b ) Derived; // 1  </div><div class="line">   b.f(); // which f() invoked?  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述两个类的大小相同，因此将Derived对象放在 Base对象中是安全的，但是在最后一句代码 中 b.f()调用的是哪一个类的f()。答案是Base::f() 的。虽然此时b中存储的实际上是一个 Derived对象，但是，通过一个对象来调用虚函数，将被静态决议出来，虚函数机制不会被启用。</p>
<p>参考：Lippman 的两本书《深度探索C++对象模型》和《C++ Primer》。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/15/Function语意学（The-Semantics-of-Function）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="suyuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏远的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/15/Function语意学（The-Semantics-of-Function）/" itemprop="url">Function语意学（The Semantics of Function）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-15T23:23:39+08:00">
                2015-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-之成员函数调用"><a href="#C-之成员函数调用" class="headerlink" title="C++之成员函数调用"></a>C++之成员函数调用</h2><p>c++支持三种类型的成员函数，分别为<code>static</code>,<code>nostatic</code>,<code>virtual</code>。每一种调用方式都不尽相同。</p>
<h3 id="非静态成员函数（Nonstatic-Member-Functions）"><a href="#非静态成员函数（Nonstatic-Member-Functions）" class="headerlink" title="非静态成员函数（Nonstatic Member Functions）"></a>非静态成员函数（Nonstatic Member Functions）</h3><p>保证nostatic member function至少必须和一般的nonmember function有相同的效率是C++的设计准则之一。事实上在c++中非静态成员函数（nostatic member function）与普通函数的调用也确实具有相同的效率，因为本质上非静态成员函数就如同一个普通函数,如一个非静态成员函数Xfloat Point::X();就相当于一个普通函数float X(Point* this);。编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p>
<ul>
<li>改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">float Point::X();</div><div class="line">//成员函数X被插入额外参数this</div><div class="line">float Point:: X(Point* this );</div><div class="line">当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</div></pre></td></tr></table></figure>
<ul>
<li><p>将每一个对非静态数据成员的操作都改写为经过this操作。</p>
</li>
<li><p>将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p>
</li>
</ul>
<p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p>
<p>由此可以做出一点总结：一个成员函数实际上就是一个被插入了一个接受其类的指针类型的额外参数的非成员函数，当然还要额外对函数的名称进行处理。额外插入的参数用来访问数据成员，而名称的特殊处理用来避免名字冲突。</p>
<p>对于名称的特殊处理并没有统一的标准，各大编译器厂商可能有不同的处理规则。在VC下上述的成员函数X()的名称X处理后就成了<code>?X@Point@@QAEMXZ</code>更多信息可以参见维基百科的Visual C++名字修饰。</p>
<p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//p-&gt;X();被转化为</div><div class="line">?X@Point@@QAEMXZ(p);</div><div class="line">//obj.X();被转化为</div><div class="line">?X@Point@@QAEMXZ(&amp;obj);</div></pre></td></tr></table></figure>
<h3 id="虚拟成员函数-Virtual-Member-Functions"><a href="#虚拟成员函数-Virtual-Member-Functions" class="headerlink" title="虚拟成员函数(Virtual Member Functions)"></a>虚拟成员函数(Virtual Member Functions)</h3><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// p-&gt;function()</div><div class="line">//将转化为</div><div class="line">(*p-&gt;vptr[1])(p);</div></pre></td></tr></table></figure>
<ul>
<li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li>
<li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().<br>何时发生这种转换？答案是在必需的时候——一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。</li>
</ul>
<h3 id="静态成员函数-Static-Member-Functions"><a href="#静态成员函数-Static-Member-Functions" class="headerlink" title="静态成员函数(Static Member Functions)"></a>静态成员函数(Static Member Functions)</h3><p>静态成员函数的一些特性：</p>
<ul>
<li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li>
<li>不能够声明为 const、voliatile或virtual。</li>
<li>它不需经由对象调用，当然，通过对象调用也被允许。<br>除了缺乏一个this指针他与非静态成员函数没有太大的差别。在这里通过对象调用和通过指针或引用调用，将被转化为同样的调用代码。</li>
</ul>
<p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(a+=b).static_fuc();</div></pre></td></tr></table></figure>
<p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间。这无疑是一个明智的规定。</p>
<h2 id="C-之虚函数-Virtual-Member-Functions"><a href="#C-之虚函数-Virtual-Member-Functions" class="headerlink" title="C++之虚函数(Virtual Member Functions)"></a>C++之虚函数(Virtual Member Functions)</h2><p>《深度探索C++对象模型》是这样来说多态的:</p>
<p>在C++中,多态表示“以一个public base<br>class的指针（或引用），寻址出一个derived class object”的意思。</p>
<h3 id="消极多态与积极多态"><a href="#消极多态与积极多态" class="headerlink" title="消极多态与积极多态"></a>消极多态与积极多态</h3><p>用基类指针来寻址继承类的对象，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point ptr=new Point3d;               //Point3d继承自Point</div></pre></td></tr></table></figure>
<p>在这种情况下，多态可以在编译期完成（虚基类情况除外），因此被称作消极多态（没有进行虚函数的调用）。相对于消极多态，则有积极多态——指向的对象类型需要在执行期在能决定。积极多态的例子如虚函数和RTTI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//例1，虚函数的调用</div><div class="line">ptr-&gt;z();</div><div class="line">//例2，RTTI 的应用</div><div class="line">if(Point3d *p=dynamic_cast&lt;Point3d*&gt;(ptr) )</div><div class="line">	return p-&gt;z();</div></pre></td></tr></table></figure>
<p>关于RTTI的笔记可见笔记EH &amp; RTTI。本文主要精力将集中于虚函数上。对于一个如上例关于虚函数的调用，要如何来保证在执行期调用的是正确的z()实体——Point3d::z()而不是调用了Point::z()。来看看虚函数的实现机制吧，它将保证这一点。</p>
<h3 id="单继承下的虚函数"><a href="#单继承下的虚函数" class="headerlink" title="单继承下的虚函数"></a>单继承下的虚函数</h3><p>虚函数的实现：</p>
<ul>
<li>为每个有虚函数的类配一张虚函数表，它存储该类类型信息和所有虚函数执行期的地址。</li>
<li>为每个有虚函数的类插入一个指针（vptr）,这个指针指向该类的虚函数表。</li>
<li>给每一个虚函数指派一个在表中的索引。<br>用这种模型来实现虚函数得益于在C++中,虚函数的地址在编译期是可知的，而且这一地址是固定不变的。而且表的大小不会在执行期增大或减小。</li>
</ul>
<p>一个类的虚函数表中存储有类型信息（存储在索引为0的位置）和所有虚函数地址，这些虚函数地址包括三种：</p>
<ul>
<li>这个类定义的虚函数，会改写（overriding）一个可能存在的基类的虚函数实体——假如基类也定义有这个虚函数。</li>
<li>继承自基类的虚函数实体，——基类定义有，而这个类却没有定义。直接继承之。</li>
<li>一个纯虚函数实体。用来在虚函数表中占座，有时候也可以当做执行期异常处理函数。<br>每一个虚函数都被指派一个固定的索引值，这个索引值在整个继承体系中保持前后关联，例如,假如z()在Point虚函数表中的索引值为2，那么在Point3d虚函数表中的索引值也为2。</li>
</ul>
<p>当一个类单继承自有虚函数的基类的时候，将按如下步骤构建虚函数表：</p>
<ul>
<li>继承基类中声明的虚函数——这些虚函数的实体地址被拷贝到继承类中的虚函数表中对于的slot中。</li>
<li>如果有改写（override）基类的虚函数，那么在1中应将改写（override）的函数实体的地址放入对应的slot中而不是拷贝基类的。</li>
<li>如果有定义新的虚函数，那么将虚函数表扩大一个slot以存放新的函数实体地址。<br>我们假设z()函数在Point虚函数表中的索引为4，回到最初的问题——要如何来保证在执行期调用的是正确的z()实体？其中微妙在于，编译将做一个小小的转换:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ptr-&gt;z();</div><div class="line">//被编译器转化为：</div><div class="line">(*ptr-&gt;vptr[4])(ptr);</div></pre></td></tr></table></figure>
<p>这个转换保证了调用到正确的实体，因为：</p>
<ul>
<li>虽然我们不知道ptr所指的真正类型,但它可以通过vptr找到正确类型的虚函数表。</li>
<li>在整个继承体系中z()的地址总是被放在slot 4。</li>
</ul>
<h3 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h3><p>在多重继承下，继承类需要为每一条继承线路维护一个虚函数表（也有可能这些表被合成为一个，但本质意义并没有变化）。当然这一切都发生在需要的情况下。</p>
<p>当使用第一继承的基类指针来调用继承类的虚函数的时候，与单继承的情况没有什么异样，问题出生在当以第二或后继的基类指针（或引用）的使用上。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//假设有这样的继承关系：class Derived:public base1,public base2;</div><div class="line">//base1,base2都定义有虚析构函数。</div><div class="line">base2 *ptr = new derived;</div><div class="line">//需要被转换为，这个转换在编译期完成</div><div class="line">base2 *ptr = temp ? temp + sizeof(base1) : 0 ;</div></pre></td></tr></table></figure>
<p>如果不做出上面的转换，那么 ptr 指向的并不是 derived 的 base2 subobject。后果是，ptr 将一个derived类型当做base2类型来用。</p>
<p>当要delete ptr时又面临了一次转换，因为在delete ptr的时候，需要对整个对象而不是其子对象施行delete运算符，这期间需要调整ptr指向完整的对象起点，因为不论是调用正确的析构函数还是delete运算符都需要一个指向对象起点的指针，想一想给予一个derived类的成员函数指向base2 subobjuect 的this指针会发生什么吧。因为ptr的具体类型并不知道，所以必须要等到执行期来完成。</p>
<p>Bjame的解决方法是将每一个虚函数表的slot扩展，以使之存放一个额外的偏移量。于是虚函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(*ptr-&gt;vptr[1])(ptr);</div><div class="line">//将变成：</div><div class="line">(*ptr-&gt;vptr[1].addr)(ptr+*ptr-&gt;vptr[1].offset);</div></pre></td></tr></table></figure></p>
<p>其中使用ptr-&gt;vptr[1].addr用以获取正确的虚函数地址，而ptr+*ptr-&gt;vptr[1].offset来获得指向对象完整的起点。这种方法的缺点显而易见，代价过大了一点，所有的情况都被这一种占比较小的情况拖累。</p>
<p>还有一种叫做thunk的方法，thunk的作用在于:</p>
<ul>
<li>以适当的offset值来this调整指针.</li>
<li>跳到虚函数中去。</li>
</ul>
<p>Thunk技术即是：虚函数表中的slot仍然继续放一个虚函数实体地址，但是如果调用这个虚函数需要进行this调整的话,该slot中的地址就指向一个Thunk而不是一个虚函数实体的地址。</p>
<p>书中纷杂的讲到不少中种情况，但我以我的理解，做如下小结：</p>
<p>多继承下的虚函数，影响到虚函数的调用的实际质上为this的调整。而this调整一般为两种：</p>
<ul>
<li>调整指针指向对应的subobject，一般发生在继承类类型指针向基类类型指针赋值的情况下。</li>
<li>将指向subobject的指针调整回继承类对象的起始点，一般发生在基类指针对继承类虚函数进行调用的时候。</li>
</ul>
<p>第一点，使得该基类指针指向一个与其指针类型匹配的子对象，唯有如此才能保证使得该指针在执行与其指针类型相匹配的特定行为的正确性。比方调用基类的成员，获得正确的虚函数地址。可以想象如果不调整，用ptr存取base2 subobject的数据成员时，会发生什么？调用base2的成员函数的时候，其成员函数接受的this指针指向derived类型对象，这又会发生什么？结果是整个对象的内存结构有可能都被破坏。还有别忘了，vptr也可以看做一个数据成员，要找到虚函数，前提是获取正确的vptr偏移量。</p>
<p>而第二点，显然是让一个继承类的虚函数获取一个正确的this指针，因为一个继承类虚函数要的是一个指向继承类对象的this指针，而不是指向其子对象。</p>
<p>第一顺序继承类之所以不需要进行调整的关键在于，其subobject的起点与继承类对象的起点一致。</p>
<h3 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h3><p>Lippman说，如果一个虚基类派生自另一虚基类，而且它们都支持虚函数和非静态数据成员的时候，编译器对虚基类的支持就像迷宫一样复杂。</p>
<p>虽然书中没有介绍太多，但不难猜测的是在虚继承情况下，复杂点在仍旧在于this指针的调整，然而其复杂度显然又在多继承之上，因为又多了一个vbptr了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://images2015.cnblogs.com/blog/564050/201707/564050-20170723222316963-2073233628.jpg"
               alt="suyuan" />
          <p class="site-author-name" itemprop="name">suyuan</p>
           
              <p class="site-description motion-element" itemprop="description">东京下雨，淋湿巴黎</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suyuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
